// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: model_config.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Triton.MemoryAnalyzer.Client
{

  /// <summary>Holder for reflection information generated from model_config.proto</summary>
  public static partial class ModelConfigReflection {

    #region Descriptor
    /// <summary>File descriptor for model_config.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ModelConfigReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChJtb2RlbF9jb25maWcucHJvdG8SFm52aWRpYS5pbmZlcmVuY2VzZXJ2ZXIi",
            "0gEKEk1vZGVsSW5zdGFuY2VHcm91cBIMCgRuYW1lGAEgASgJEj0KBGtpbmQY",
            "BCABKA4yLy5udmlkaWEuaW5mZXJlbmNlc2VydmVyLk1vZGVsSW5zdGFuY2VH",
            "cm91cC5LaW5kEg0KBWNvdW50GAIgASgFEgwKBGdwdXMYAyADKAUSDwoHcHJv",
            "ZmlsZRgFIAMoCSJBCgRLaW5kEg0KCUtJTkRfQVVUTxAAEgwKCEtJTkRfR1BV",
            "EAESDAoIS0lORF9DUFUQAhIOCgpLSU5EX01PREVMEAMiIwoSTW9kZWxUZW5z",
            "b3JSZXNoYXBlEg0KBXNoYXBlGAEgAygDIpICCgpNb2RlbElucHV0EgwKBG5h",
            "bWUYASABKAkSMwoJZGF0YV90eXBlGAIgASgOMiAubnZpZGlhLmluZmVyZW5j",
            "ZXNlcnZlci5EYXRhVHlwZRI5CgZmb3JtYXQYAyABKA4yKS5udmlkaWEuaW5m",
            "ZXJlbmNlc2VydmVyLk1vZGVsSW5wdXQuRm9ybWF0EgwKBGRpbXMYBCADKAMS",
            "OwoHcmVzaGFwZRgFIAEoCzIqLm52aWRpYS5pbmZlcmVuY2VzZXJ2ZXIuTW9k",
            "ZWxUZW5zb3JSZXNoYXBlIjsKBkZvcm1hdBIPCgtGT1JNQVRfTk9ORRAAEg8K",
            "C0ZPUk1BVF9OSFdDEAESDwoLRk9STUFUX05DSFcQAiKzAQoLTW9kZWxPdXRw",
            "dXQSDAoEbmFtZRgBIAEoCRIzCglkYXRhX3R5cGUYAiABKA4yIC5udmlkaWEu",
            "aW5mZXJlbmNlc2VydmVyLkRhdGFUeXBlEgwKBGRpbXMYAyADKAMSOwoHcmVz",
            "aGFwZRgFIAEoCzIqLm52aWRpYS5pbmZlcmVuY2VzZXJ2ZXIuTW9kZWxUZW5z",
            "b3JSZXNoYXBlEhYKDmxhYmVsX2ZpbGVuYW1lGAQgASgJIrcCChJNb2RlbFZl",
            "cnNpb25Qb2xpY3kSQwoGbGF0ZXN0GAEgASgLMjEubnZpZGlhLmluZmVyZW5j",
            "ZXNlcnZlci5Nb2RlbFZlcnNpb25Qb2xpY3kuTGF0ZXN0SAASPQoDYWxsGAIg",
            "ASgLMi4ubnZpZGlhLmluZmVyZW5jZXNlcnZlci5Nb2RlbFZlcnNpb25Qb2xp",
            "Y3kuQWxsSAASRwoIc3BlY2lmaWMYAyABKAsyMy5udmlkaWEuaW5mZXJlbmNl",
            "c2VydmVyLk1vZGVsVmVyc2lvblBvbGljeS5TcGVjaWZpY0gAGh4KBkxhdGVz",
            "dBIUCgxudW1fdmVyc2lvbnMYASABKA0aBQoDQWxsGhwKCFNwZWNpZmljEhAK",
            "CHZlcnNpb25zGAEgAygDQg8KDXBvbGljeV9jaG9pY2UipAcKF01vZGVsT3B0",
            "aW1pemF0aW9uUG9saWN5EkQKBWdyYXBoGAEgASgLMjUubnZpZGlhLmluZmVy",
            "ZW5jZXNlcnZlci5Nb2RlbE9wdGltaXphdGlvblBvbGljeS5HcmFwaBJPCghw",
            "cmlvcml0eRgCIAEoDjI9Lm52aWRpYS5pbmZlcmVuY2VzZXJ2ZXIuTW9kZWxP",
            "cHRpbWl6YXRpb25Qb2xpY3kuTW9kZWxQcmlvcml0eRJCCgRjdWRhGAMgASgL",
            "MjQubnZpZGlhLmluZmVyZW5jZXNlcnZlci5Nb2RlbE9wdGltaXphdGlvblBv",
            "bGljeS5DdWRhEmUKFmV4ZWN1dGlvbl9hY2NlbGVyYXRvcnMYBCABKAsyRS5u",
            "dmlkaWEuaW5mZXJlbmNlc2VydmVyLk1vZGVsT3B0aW1pemF0aW9uUG9saWN5",
            "LkV4ZWN1dGlvbkFjY2VsZXJhdG9ycxoWCgVHcmFwaBINCgVsZXZlbBgBIAEo",
            "BRoWCgRDdWRhEg4KBmdyYXBocxgBIAEoCBrLAwoVRXhlY3V0aW9uQWNjZWxl",
            "cmF0b3JzEnQKGWdwdV9leGVjdXRpb25fYWNjZWxlcmF0b3IYASADKAsyUS5u",
            "dmlkaWEuaW5mZXJlbmNlc2VydmVyLk1vZGVsT3B0aW1pemF0aW9uUG9saWN5",
            "LkV4ZWN1dGlvbkFjY2VsZXJhdG9ycy5BY2NlbGVyYXRvchJ0ChljcHVfZXhl",
            "Y3V0aW9uX2FjY2VsZXJhdG9yGAIgAygLMlEubnZpZGlhLmluZmVyZW5jZXNl",
            "cnZlci5Nb2RlbE9wdGltaXphdGlvblBvbGljeS5FeGVjdXRpb25BY2NlbGVy",
            "YXRvcnMuQWNjZWxlcmF0b3IaxQEKC0FjY2VsZXJhdG9yEgwKBG5hbWUYASAB",
            "KAkSdQoKcGFyYW1ldGVycxgCIAMoCzJhLm52aWRpYS5pbmZlcmVuY2VzZXJ2",
            "ZXIuTW9kZWxPcHRpbWl6YXRpb25Qb2xpY3kuRXhlY3V0aW9uQWNjZWxlcmF0",
            "b3JzLkFjY2VsZXJhdG9yLlBhcmFtZXRlcnNFbnRyeRoxCg9QYXJhbWV0ZXJz",
            "RW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASJJCg1Nb2Rl",
            "bFByaW9yaXR5EhQKEFBSSU9SSVRZX0RFRkFVTFQQABIQCgxQUklPUklUWV9N",
            "QVgQARIQCgxQUklPUklUWV9NSU4QAiJ1ChRNb2RlbER5bmFtaWNCYXRjaGlu",
            "ZxIcChRwcmVmZXJyZWRfYmF0Y2hfc2l6ZRgBIAMoBRIkChxtYXhfcXVldWVf",
            "ZGVsYXlfbWljcm9zZWNvbmRzGAIgASgEEhkKEXByZXNlcnZlX29yZGVyaW5n",
            "GAMgASgIIukGChVNb2RlbFNlcXVlbmNlQmF0Y2hpbmcSTgoGZGlyZWN0GAMg",
            "ASgLMjwubnZpZGlhLmluZmVyZW5jZXNlcnZlci5Nb2RlbFNlcXVlbmNlQmF0",
            "Y2hpbmcuU3RyYXRlZ3lEaXJlY3RIABJOCgZvbGRlc3QYBCABKAsyPC5udmlk",
            "aWEuaW5mZXJlbmNlc2VydmVyLk1vZGVsU2VxdWVuY2VCYXRjaGluZy5TdHJh",
            "dGVneU9sZGVzdEgAEiYKHm1heF9zZXF1ZW5jZV9pZGxlX21pY3Jvc2Vjb25k",
            "cxgBIAEoBBJRCg1jb250cm9sX2lucHV0GAIgAygLMjoubnZpZGlhLmluZmVy",
            "ZW5jZXNlcnZlci5Nb2RlbFNlcXVlbmNlQmF0Y2hpbmcuQ29udHJvbElucHV0",
            "GrICCgdDb250cm9sEkgKBGtpbmQYASABKA4yOi5udmlkaWEuaW5mZXJlbmNl",
            "c2VydmVyLk1vZGVsU2VxdWVuY2VCYXRjaGluZy5Db250cm9sLktpbmQSGAoQ",
            "aW50MzJfZmFsc2VfdHJ1ZRgCIAMoBRIXCg9mcDMyX2ZhbHNlX3RydWUYAyAD",
            "KAISMwoJZGF0YV90eXBlGAQgASgOMiAubnZpZGlhLmluZmVyZW5jZXNlcnZl",
            "ci5EYXRhVHlwZSJ1CgRLaW5kEhoKFkNPTlRST0xfU0VRVUVOQ0VfU1RBUlQQ",
            "ABIaChZDT05UUk9MX1NFUVVFTkNFX1JFQURZEAESGAoUQ09OVFJPTF9TRVFV",
            "RU5DRV9FTkQQAhIbChdDT05UUk9MX1NFUVVFTkNFX0NPUlJJRBADGmQKDENv",
            "bnRyb2xJbnB1dBIMCgRuYW1lGAEgASgJEkYKB2NvbnRyb2wYAiADKAsyNS5u",
            "dmlkaWEuaW5mZXJlbmNlc2VydmVyLk1vZGVsU2VxdWVuY2VCYXRjaGluZy5D",
            "b250cm9sGhAKDlN0cmF0ZWd5RGlyZWN0GnUKDlN0cmF0ZWd5T2xkZXN0Eh8K",
            "F21heF9jYW5kaWRhdGVfc2VxdWVuY2VzGAEgASgFEhwKFHByZWZlcnJlZF9i",
            "YXRjaF9zaXplGAIgAygFEiQKHG1heF9xdWV1ZV9kZWxheV9taWNyb3NlY29u",
            "ZHMYAyABKARCEQoPc3RyYXRlZ3lfY2hvaWNlIoQDCg9Nb2RlbEVuc2VtYmxp",
            "bmcSOgoEc3RlcBgBIAMoCzIsLm52aWRpYS5pbmZlcmVuY2VzZXJ2ZXIuTW9k",
            "ZWxFbnNlbWJsaW5nLlN0ZXAatAIKBFN0ZXASEgoKbW9kZWxfbmFtZRgBIAEo",
            "CRIVCg1tb2RlbF92ZXJzaW9uGAIgASgDEk0KCWlucHV0X21hcBgDIAMoCzI6",
            "Lm52aWRpYS5pbmZlcmVuY2VzZXJ2ZXIuTW9kZWxFbnNlbWJsaW5nLlN0ZXAu",
            "SW5wdXRNYXBFbnRyeRJPCgpvdXRwdXRfbWFwGAQgAygLMjsubnZpZGlhLmlu",
            "ZmVyZW5jZXNlcnZlci5Nb2RlbEVuc2VtYmxpbmcuU3RlcC5PdXRwdXRNYXBF",
            "bnRyeRovCg1JbnB1dE1hcEVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgC",
            "IAEoCToCOAEaMAoOT3V0cHV0TWFwRW50cnkSCwoDa2V5GAEgASgJEg0KBXZh",
            "bHVlGAIgASgJOgI4ASImCg5Nb2RlbFBhcmFtZXRlchIUCgxzdHJpbmdfdmFs",
            "dWUYASABKAki8QIKC01vZGVsV2FybXVwEgwKBG5hbWUYASABKAkSEgoKYmF0",
            "Y2hfc2l6ZRgCIAEoDRI/CgZpbnB1dHMYAyADKAsyLy5udmlkaWEuaW5mZXJl",
            "bmNlc2VydmVyLk1vZGVsV2FybXVwLklucHV0c0VudHJ5GqQBCgVJbnB1dBIz",
            "CglkYXRhX3R5cGUYASABKA4yIC5udmlkaWEuaW5mZXJlbmNlc2VydmVyLkRh",
            "dGFUeXBlEgwKBGRpbXMYAiADKAMSEwoJemVyb19kYXRhGAMgASgISAASFQoL",
            "cmFuZG9tX2RhdGEYBCABKAhIABIZCg9pbnB1dF9kYXRhX2ZpbGUYBSABKAlI",
            "AEIRCg9pbnB1dF9kYXRhX3R5cGUaWAoLSW5wdXRzRW50cnkSCwoDa2V5GAEg",
            "ASgJEjgKBXZhbHVlGAIgASgLMikubnZpZGlhLmluZmVyZW5jZXNlcnZlci5N",
            "b2RlbFdhcm11cC5JbnB1dDoCOAEi+wgKC01vZGVsQ29uZmlnEgwKBG5hbWUY",
            "ASABKAkSEAoIcGxhdGZvcm0YAiABKAkSQgoOdmVyc2lvbl9wb2xpY3kYAyAB",
            "KAsyKi5udmlkaWEuaW5mZXJlbmNlc2VydmVyLk1vZGVsVmVyc2lvblBvbGlj",
            "eRIWCg5tYXhfYmF0Y2hfc2l6ZRgEIAEoBRIxCgVpbnB1dBgFIAMoCzIiLm52",
            "aWRpYS5pbmZlcmVuY2VzZXJ2ZXIuTW9kZWxJbnB1dBIzCgZvdXRwdXQYBiAD",
            "KAsyIy5udmlkaWEuaW5mZXJlbmNlc2VydmVyLk1vZGVsT3V0cHV0EkUKDG9w",
            "dGltaXphdGlvbhgMIAEoCzIvLm52aWRpYS5pbmZlcmVuY2VzZXJ2ZXIuTW9k",
            "ZWxPcHRpbWl6YXRpb25Qb2xpY3kSSAoQZHluYW1pY19iYXRjaGluZxgLIAEo",
            "CzIsLm52aWRpYS5pbmZlcmVuY2VzZXJ2ZXIuTW9kZWxEeW5hbWljQmF0Y2hp",
            "bmdIABJKChFzZXF1ZW5jZV9iYXRjaGluZxgNIAEoCzItLm52aWRpYS5pbmZl",
            "cmVuY2VzZXJ2ZXIuTW9kZWxTZXF1ZW5jZUJhdGNoaW5nSAASRgoTZW5zZW1i",
            "bGVfc2NoZWR1bGluZxgPIAEoCzInLm52aWRpYS5pbmZlcmVuY2VzZXJ2ZXIu",
            "TW9kZWxFbnNlbWJsaW5nSAASQgoOaW5zdGFuY2VfZ3JvdXAYByADKAsyKi5u",
            "dmlkaWEuaW5mZXJlbmNlc2VydmVyLk1vZGVsSW5zdGFuY2VHcm91cBIeChZk",
            "ZWZhdWx0X21vZGVsX2ZpbGVuYW1lGAggASgJElUKEmNjX21vZGVsX2ZpbGVu",
            "YW1lcxgJIAMoCzI5Lm52aWRpYS5pbmZlcmVuY2VzZXJ2ZXIuTW9kZWxDb25m",
            "aWcuQ2NNb2RlbEZpbGVuYW1lc0VudHJ5EkgKC21ldHJpY190YWdzGAogAygL",
            "MjMubnZpZGlhLmluZmVyZW5jZXNlcnZlci5Nb2RlbENvbmZpZy5NZXRyaWNU",
            "YWdzRW50cnkSRwoKcGFyYW1ldGVycxgOIAMoCzIzLm52aWRpYS5pbmZlcmVu",
            "Y2VzZXJ2ZXIuTW9kZWxDb25maWcuUGFyYW1ldGVyc0VudHJ5EjkKDG1vZGVs",
            "X3dhcm11cBgQIAMoCzIjLm52aWRpYS5pbmZlcmVuY2VzZXJ2ZXIuTW9kZWxX",
            "YXJtdXAaNwoVQ2NNb2RlbEZpbGVuYW1lc0VudHJ5EgsKA2tleRgBIAEoCRIN",
            "CgV2YWx1ZRgCIAEoCToCOAEaMQoPTWV0cmljVGFnc0VudHJ5EgsKA2tleRgB",
            "IAEoCRINCgV2YWx1ZRgCIAEoCToCOAEaWQoPUGFyYW1ldGVyc0VudHJ5EgsK",
            "A2tleRgBIAEoCRI1CgV2YWx1ZRgCIAEoCzImLm52aWRpYS5pbmZlcmVuY2Vz",
            "ZXJ2ZXIuTW9kZWxQYXJhbWV0ZXI6AjgBQhMKEXNjaGVkdWxpbmdfY2hvaWNl",
            "KusBCghEYXRhVHlwZRIQCgxUWVBFX0lOVkFMSUQQABINCglUWVBFX0JPT0wQ",
            "ARIOCgpUWVBFX1VJTlQ4EAISDwoLVFlQRV9VSU5UMTYQAxIPCgtUWVBFX1VJ",
            "TlQzMhAEEg8KC1RZUEVfVUlOVDY0EAUSDQoJVFlQRV9JTlQ4EAYSDgoKVFlQ",
            "RV9JTlQxNhAHEg4KClRZUEVfSU5UMzIQCBIOCgpUWVBFX0lOVDY0EAkSDQoJ",
            "VFlQRV9GUDE2EAoSDQoJVFlQRV9GUDMyEAsSDQoJVFlQRV9GUDY0EAwSDwoL",
            "VFlQRV9TVFJJTkcQDWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Triton.MemoryAnalyzer.Client.DataType), }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelInstanceGroup), global::Triton.MemoryAnalyzer.Client.ModelInstanceGroup.Parser, new[]{ "Name", "Kind", "Count", "Gpus", "Profile" }, null, new[]{ typeof(global::Triton.MemoryAnalyzer.Client.ModelInstanceGroup.Types.Kind) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelTensorReshape), global::Triton.MemoryAnalyzer.Client.ModelTensorReshape.Parser, new[]{ "Shape" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelInput), global::Triton.MemoryAnalyzer.Client.ModelInput.Parser, new[]{ "Name", "DataType", "Format", "Dims", "Reshape" }, null, new[]{ typeof(global::Triton.MemoryAnalyzer.Client.ModelInput.Types.Format) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelOutput), global::Triton.MemoryAnalyzer.Client.ModelOutput.Parser, new[]{ "Name", "DataType", "Dims", "Reshape", "LabelFilename" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy), global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Parser, new[]{ "Latest", "All", "Specific" }, new[]{ "PolicyChoice" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.Latest), global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.Latest.Parser, new[]{ "NumVersions" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.All), global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.All.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.Specific), global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.Specific.Parser, new[]{ "Versions" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy), global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Parser, new[]{ "Graph", "Priority", "Cuda", "ExecutionAccelerators" }, null, new[]{ typeof(global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ModelPriority) }, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.Graph), global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.Graph.Parser, new[]{ "Level" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.Cuda), global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.Cuda.Parser, new[]{ "Graphs" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ExecutionAccelerators), global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ExecutionAccelerators.Parser, new[]{ "GpuExecutionAccelerator", "CpuExecutionAccelerator" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator), global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator.Parser, new[]{ "Name", "Parameters" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, })})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelDynamicBatching), global::Triton.MemoryAnalyzer.Client.ModelDynamicBatching.Parser, new[]{ "PreferredBatchSize", "MaxQueueDelayMicroseconds", "PreserveOrdering" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching), global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Parser, new[]{ "Direct", "Oldest", "MaxSequenceIdleMicroseconds", "ControlInput" }, new[]{ "StrategyChoice" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.Control), global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.Control.Parser, new[]{ "Kind", "Int32FalseTrue", "Fp32FalseTrue", "DataType" }, null, new[]{ typeof(global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.Control.Types.Kind) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.ControlInput), global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.ControlInput.Parser, new[]{ "Name", "Control" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.StrategyDirect), global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.StrategyDirect.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.StrategyOldest), global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.StrategyOldest.Parser, new[]{ "MaxCandidateSequences", "PreferredBatchSize", "MaxQueueDelayMicroseconds" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelEnsembling), global::Triton.MemoryAnalyzer.Client.ModelEnsembling.Parser, new[]{ "Step" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelEnsembling.Types.Step), global::Triton.MemoryAnalyzer.Client.ModelEnsembling.Types.Step.Parser, new[]{ "ModelName", "ModelVersion", "InputMap", "OutputMap" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, })}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelParameter), global::Triton.MemoryAnalyzer.Client.ModelParameter.Parser, new[]{ "StringValue" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelWarmup), global::Triton.MemoryAnalyzer.Client.ModelWarmup.Parser, new[]{ "Name", "BatchSize", "Inputs" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelWarmup.Types.Input), global::Triton.MemoryAnalyzer.Client.ModelWarmup.Types.Input.Parser, new[]{ "DataType", "Dims", "ZeroData", "RandomData", "InputDataFile" }, new[]{ "InputDataType" }, null, null),
            null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Triton.MemoryAnalyzer.Client.ModelConfig), global::Triton.MemoryAnalyzer.Client.ModelConfig.Parser, new[]{ "Name", "Platform", "VersionPolicy", "MaxBatchSize", "Input", "Output", "Optimization", "DynamicBatching", "SequenceBatching", "EnsembleScheduling", "InstanceGroup", "DefaultModelFilename", "CcModelFilenames", "MetricTags", "Parameters", "ModelWarmup" }, new[]{ "SchedulingChoice" }, null, new pbr::GeneratedClrTypeInfo[] { null, null, null, })
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  ///@@
  ///@@.. cpp:enum:: DataType
  ///@@
  ///@@   Data types supported for input and output tensors.
  ///@@
  /// </summary>
  public enum DataType {
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::INVALID = 0
    /// </summary>
    [pbr::OriginalName("TYPE_INVALID")] TypeInvalid = 0,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::BOOL = 1
    /// </summary>
    [pbr::OriginalName("TYPE_BOOL")] TypeBool = 1,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::UINT8 = 2
    /// </summary>
    [pbr::OriginalName("TYPE_UINT8")] TypeUint8 = 2,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::UINT16 = 3
    /// </summary>
    [pbr::OriginalName("TYPE_UINT16")] TypeUint16 = 3,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::UINT32 = 4
    /// </summary>
    [pbr::OriginalName("TYPE_UINT32")] TypeUint32 = 4,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::UINT64 = 5
    /// </summary>
    [pbr::OriginalName("TYPE_UINT64")] TypeUint64 = 5,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::INT8 = 6
    /// </summary>
    [pbr::OriginalName("TYPE_INT8")] TypeInt8 = 6,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::INT16 = 7
    /// </summary>
    [pbr::OriginalName("TYPE_INT16")] TypeInt16 = 7,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::INT32 = 8
    /// </summary>
    [pbr::OriginalName("TYPE_INT32")] TypeInt32 = 8,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::INT64 = 9
    /// </summary>
    [pbr::OriginalName("TYPE_INT64")] TypeInt64 = 9,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::FP16 = 10
    /// </summary>
    [pbr::OriginalName("TYPE_FP16")] TypeFp16 = 10,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::FP32 = 11
    /// </summary>
    [pbr::OriginalName("TYPE_FP32")] TypeFp32 = 11,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::FP64 = 12
    /// </summary>
    [pbr::OriginalName("TYPE_FP64")] TypeFp64 = 12,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::STRING = 13
    /// </summary>
    [pbr::OriginalName("TYPE_STRING")] TypeString = 13,
  }

  #endregion

  #region Messages
  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelInstanceGroup
  ///@@
  ///@@   A group of one or more instances of a model and resources made
  ///@@   available for those instances.
  ///@@
  /// </summary>
  public sealed partial class ModelInstanceGroup : pb::IMessage<ModelInstanceGroup> {
    private static readonly pb::MessageParser<ModelInstanceGroup> _parser = new pb::MessageParser<ModelInstanceGroup>(() => new ModelInstanceGroup());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ModelInstanceGroup> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Triton.MemoryAnalyzer.Client.ModelConfigReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelInstanceGroup() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelInstanceGroup(ModelInstanceGroup other) : this() {
      name_ = other.name_;
      kind_ = other.kind_;
      count_ = other.count_;
      gpus_ = other.gpus_.Clone();
      profile_ = other.profile_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelInstanceGroup Clone() {
      return new ModelInstanceGroup(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    ///@@  .. cpp:var:: string name
    ///@@
    ///@@     Optional name of this group of instances. If not specified the
    ///@@     name will be formed as &lt;model name>_&lt;group number>. The name of
    ///@@     individual instances will be further formed by a unique instance
    ///@@     number and GPU index:
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "kind" field.</summary>
    public const int KindFieldNumber = 4;
    private global::Triton.MemoryAnalyzer.Client.ModelInstanceGroup.Types.Kind kind_ = 0;
    /// <summary>
    ///@@  .. cpp:var:: Kind kind
    ///@@
    ///@@     The kind of this instance group. Default is KIND_AUTO. If
    ///@@     KIND_AUTO or KIND_GPU then both 'count' and 'gpu' are valid and
    ///@@     may be specified. If KIND_CPU or KIND_MODEL only 'count' is valid
    ///@@     and 'gpu' cannot be specified.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Triton.MemoryAnalyzer.Client.ModelInstanceGroup.Types.Kind Kind {
      get { return kind_; }
      set {
        kind_ = value;
      }
    }

    /// <summary>Field number for the "count" field.</summary>
    public const int CountFieldNumber = 2;
    private int count_;
    /// <summary>
    ///@@  .. cpp:var:: int32 count
    ///@@
    ///@@     For a group assigned to GPU, the number of instances created for
    ///@@     each GPU listed in 'gpus'. For a group assigned to CPU the number
    ///@@     of instances created. Default is 1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Count {
      get { return count_; }
      set {
        count_ = value;
      }
    }

    /// <summary>Field number for the "gpus" field.</summary>
    public const int GpusFieldNumber = 3;
    private static readonly pb::FieldCodec<int> _repeated_gpus_codec
        = pb::FieldCodec.ForInt32(26);
    private readonly pbc::RepeatedField<int> gpus_ = new pbc::RepeatedField<int>();
    /// <summary>
    ///@@  .. cpp:var:: int32 gpus (repeated)
    ///@@
    ///@@     GPU(s) where instances should be available. For each GPU listed,
    ///@@     'count' instances of the model will be available. Setting 'gpus'
    ///@@     to empty (or not specifying at all) is eqivalent to listing all
    ///@@     available GPUs.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> Gpus {
      get { return gpus_; }
    }

    /// <summary>Field number for the "profile" field.</summary>
    public const int ProfileFieldNumber = 5;
    private static readonly pb::FieldCodec<string> _repeated_profile_codec
        = pb::FieldCodec.ForString(42);
    private readonly pbc::RepeatedField<string> profile_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///@@  .. cpp:var:: string profile (repeated)
    ///@@
    ///@@     For TensorRT models, using inputs with dynamic shape, this
    ///@@     parameter specifies a set of optimization profiles available to this
    ///@@     instance group. The inference server will choose the optimal profile
    ///@@     based on the shapes of the input tensors. This field should lie
    ///@@     between 0 and &lt;TotalNumberOfOptimizationProfilesInPlanModel> - 1
    ///@@     and be specified only for TensorRT backend, otherwise an error will
    ///@@     be generated.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Profile {
      get { return profile_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ModelInstanceGroup);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ModelInstanceGroup other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Kind != other.Kind) return false;
      if (Count != other.Count) return false;
      if(!gpus_.Equals(other.gpus_)) return false;
      if(!profile_.Equals(other.profile_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Kind != 0) hash ^= Kind.GetHashCode();
      if (Count != 0) hash ^= Count.GetHashCode();
      hash ^= gpus_.GetHashCode();
      hash ^= profile_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Count != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(Count);
      }
      gpus_.WriteTo(output, _repeated_gpus_codec);
      if (Kind != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Kind);
      }
      profile_.WriteTo(output, _repeated_profile_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Kind != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Kind);
      }
      if (Count != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Count);
      }
      size += gpus_.CalculateSize(_repeated_gpus_codec);
      size += profile_.CalculateSize(_repeated_profile_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ModelInstanceGroup other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Kind != 0) {
        Kind = other.Kind;
      }
      if (other.Count != 0) {
        Count = other.Count;
      }
      gpus_.Add(other.gpus_);
      profile_.Add(other.profile_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Count = input.ReadInt32();
            break;
          }
          case 26:
          case 24: {
            gpus_.AddEntriesFrom(input, _repeated_gpus_codec);
            break;
          }
          case 32: {
            Kind = (global::Triton.MemoryAnalyzer.Client.ModelInstanceGroup.Types.Kind) input.ReadEnum();
            break;
          }
          case 42: {
            profile_.AddEntriesFrom(input, _repeated_profile_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ModelInstanceGroup message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///@@
      ///@@  .. cpp:enum:: Kind
      ///@@
      ///@@     Kind of this instance group.
      ///@@
      /// </summary>
      public enum Kind {
        /// <summary>
        ///@@    .. cpp:enumerator:: Kind::KIND_AUTO = 0
        ///@@
        ///@@       This instance group represents instances that can run on either
        ///@@       CPU or GPU. If all GPUs listed in 'gpus' are available then
        ///@@       instances will be created on GPU(s), otherwise instances will
        ///@@       be created on CPU.
        ///@@
        /// </summary>
        [pbr::OriginalName("KIND_AUTO")] Auto = 0,
        /// <summary>
        ///@@    .. cpp:enumerator:: Kind::KIND_GPU = 1
        ///@@
        ///@@       This instance group represents instances that must run on the
        ///@@       GPU.
        ///@@
        /// </summary>
        [pbr::OriginalName("KIND_GPU")] Gpu = 1,
        /// <summary>
        ///@@    .. cpp:enumerator:: Kind::KIND_CPU = 2
        ///@@
        ///@@       This instance group represents instances that must run on the
        ///@@       CPU.
        ///@@
        /// </summary>
        [pbr::OriginalName("KIND_CPU")] Cpu = 2,
        /// <summary>
        ///@@    .. cpp:enumerator:: Kind::KIND_MODEL = 3
        ///@@
        ///@@       This instance group represents instances that should run on the
        ///@@       CPU and/or GPU(s) as specified by the model or backend itself.
        ///@@       The inference server will not override the model/backend
        ///@@       settings.
        ///@@       Currently, this option is supported only for Tensorflow models.
        ///@@
        /// </summary>
        [pbr::OriginalName("KIND_MODEL")] Model = 3,
      }

    }
    #endregion

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelTensorReshape
  ///@@
  ///@@   Reshape specification for input and output tensors.
  ///@@
  /// </summary>
  public sealed partial class ModelTensorReshape : pb::IMessage<ModelTensorReshape> {
    private static readonly pb::MessageParser<ModelTensorReshape> _parser = new pb::MessageParser<ModelTensorReshape>(() => new ModelTensorReshape());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ModelTensorReshape> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Triton.MemoryAnalyzer.Client.ModelConfigReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelTensorReshape() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelTensorReshape(ModelTensorReshape other) : this() {
      shape_ = other.shape_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelTensorReshape Clone() {
      return new ModelTensorReshape(this);
    }

    /// <summary>Field number for the "shape" field.</summary>
    public const int ShapeFieldNumber = 1;
    private static readonly pb::FieldCodec<long> _repeated_shape_codec
        = pb::FieldCodec.ForInt64(10);
    private readonly pbc::RepeatedField<long> shape_ = new pbc::RepeatedField<long>();
    /// <summary>
    ///@@  .. cpp:var:: int64 shape (repeated)
    ///@@
    ///@@     The shape to use for reshaping.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> Shape {
      get { return shape_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ModelTensorReshape);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ModelTensorReshape other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!shape_.Equals(other.shape_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= shape_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      shape_.WriteTo(output, _repeated_shape_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += shape_.CalculateSize(_repeated_shape_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ModelTensorReshape other) {
      if (other == null) {
        return;
      }
      shape_.Add(other.shape_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            shape_.AddEntriesFrom(input, _repeated_shape_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelInput
  ///@@
  ///@@   An input required by the model.
  ///@@
  /// </summary>
  public sealed partial class ModelInput : pb::IMessage<ModelInput> {
    private static readonly pb::MessageParser<ModelInput> _parser = new pb::MessageParser<ModelInput>(() => new ModelInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ModelInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Triton.MemoryAnalyzer.Client.ModelConfigReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelInput(ModelInput other) : this() {
      name_ = other.name_;
      dataType_ = other.dataType_;
      format_ = other.format_;
      dims_ = other.dims_.Clone();
      reshape_ = other.reshape_ != null ? other.reshape_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelInput Clone() {
      return new ModelInput(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    ///@@  .. cpp:var:: string name
    ///@@
    ///@@     The name of the input.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "data_type" field.</summary>
    public const int DataTypeFieldNumber = 2;
    private global::Triton.MemoryAnalyzer.Client.DataType dataType_ = 0;
    /// <summary>
    ///@@  .. cpp:var:: DataType data_type
    ///@@
    ///@@     The data-type of the input.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Triton.MemoryAnalyzer.Client.DataType DataType {
      get { return dataType_; }
      set {
        dataType_ = value;
      }
    }

    /// <summary>Field number for the "format" field.</summary>
    public const int FormatFieldNumber = 3;
    private global::Triton.MemoryAnalyzer.Client.ModelInput.Types.Format format_ = 0;
    /// <summary>
    ///@@  .. cpp:var:: Format format
    ///@@
    ///@@     The format of the input. Optional.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Triton.MemoryAnalyzer.Client.ModelInput.Types.Format Format {
      get { return format_; }
      set {
        format_ = value;
      }
    }

    /// <summary>Field number for the "dims" field.</summary>
    public const int DimsFieldNumber = 4;
    private static readonly pb::FieldCodec<long> _repeated_dims_codec
        = pb::FieldCodec.ForInt64(34);
    private readonly pbc::RepeatedField<long> dims_ = new pbc::RepeatedField<long>();
    /// <summary>
    ///@@  .. cpp:var:: int64 dims (repeated)
    ///@@
    ///@@     The dimensions/shape of the input tensor that must be provided
    ///@@     when invoking the inference API for this model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> Dims {
      get { return dims_; }
    }

    /// <summary>Field number for the "reshape" field.</summary>
    public const int ReshapeFieldNumber = 5;
    private global::Triton.MemoryAnalyzer.Client.ModelTensorReshape reshape_;
    /// <summary>
    ///@@  .. cpp:var:: ModelTensorReshape reshape
    ///@@
    ///@@     The shape expected for this input by the backend. The input will
    ///@@     be reshaped to this before being presented to the backend. The
    ///@@     reshape must have the same number of elements as the input shape
    ///@@     specified by 'dims'. Optional.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Triton.MemoryAnalyzer.Client.ModelTensorReshape Reshape {
      get { return reshape_; }
      set {
        reshape_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ModelInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ModelInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (DataType != other.DataType) return false;
      if (Format != other.Format) return false;
      if(!dims_.Equals(other.dims_)) return false;
      if (!object.Equals(Reshape, other.Reshape)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (DataType != 0) hash ^= DataType.GetHashCode();
      if (Format != 0) hash ^= Format.GetHashCode();
      hash ^= dims_.GetHashCode();
      if (reshape_ != null) hash ^= Reshape.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (DataType != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DataType);
      }
      if (Format != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Format);
      }
      dims_.WriteTo(output, _repeated_dims_codec);
      if (reshape_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Reshape);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (DataType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DataType);
      }
      if (Format != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Format);
      }
      size += dims_.CalculateSize(_repeated_dims_codec);
      if (reshape_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Reshape);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ModelInput other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.DataType != 0) {
        DataType = other.DataType;
      }
      if (other.Format != 0) {
        Format = other.Format;
      }
      dims_.Add(other.dims_);
      if (other.reshape_ != null) {
        if (reshape_ == null) {
          Reshape = new global::Triton.MemoryAnalyzer.Client.ModelTensorReshape();
        }
        Reshape.MergeFrom(other.Reshape);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            DataType = (global::Triton.MemoryAnalyzer.Client.DataType) input.ReadEnum();
            break;
          }
          case 24: {
            Format = (global::Triton.MemoryAnalyzer.Client.ModelInput.Types.Format) input.ReadEnum();
            break;
          }
          case 34:
          case 32: {
            dims_.AddEntriesFrom(input, _repeated_dims_codec);
            break;
          }
          case 42: {
            if (reshape_ == null) {
              Reshape = new global::Triton.MemoryAnalyzer.Client.ModelTensorReshape();
            }
            input.ReadMessage(Reshape);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ModelInput message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///@@
      ///@@  .. cpp:enum:: Format
      ///@@
      ///@@     The format for the input.
      ///@@
      /// </summary>
      public enum Format {
        /// <summary>
        ///@@    .. cpp:enumerator:: Format::FORMAT_NONE = 0
        ///@@
        ///@@       The input has no specific format. This is the default.
        ///@@
        /// </summary>
        [pbr::OriginalName("FORMAT_NONE")] None = 0,
        /// <summary>
        ///@@    .. cpp:enumerator:: Format::FORMAT_NHWC = 1
        ///@@
        ///@@       HWC image format. Tensors with this format require 3 dimensions
        ///@@       if the model does not support batching (max_batch_size = 0) or 4
        ///@@       dimensions if the model does support batching (max_batch_size
        ///@@       >= 1). In either case the 'dims' below should only specify the
        ///@@       3 non-batch dimensions (i.e. HWC or CHW).
        ///@@
        /// </summary>
        [pbr::OriginalName("FORMAT_NHWC")] Nhwc = 1,
        /// <summary>
        ///@@    .. cpp:enumerator:: Format::FORMAT_NCHW = 2
        ///@@
        ///@@       CHW image format. Tensors with this format require 3 dimensions
        ///@@       if the model does not support batching (max_batch_size = 0) or 4
        ///@@       dimensions if the model does support batching (max_batch_size
        ///@@       >= 1). In either case the 'dims' below should only specify the
        ///@@       3 non-batch dimensions (i.e. HWC or CHW).
        ///@@
        /// </summary>
        [pbr::OriginalName("FORMAT_NCHW")] Nchw = 2,
      }

    }
    #endregion

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelOutput
  ///@@
  ///@@   An output produced by the model.
  ///@@
  /// </summary>
  public sealed partial class ModelOutput : pb::IMessage<ModelOutput> {
    private static readonly pb::MessageParser<ModelOutput> _parser = new pb::MessageParser<ModelOutput>(() => new ModelOutput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ModelOutput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Triton.MemoryAnalyzer.Client.ModelConfigReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelOutput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelOutput(ModelOutput other) : this() {
      name_ = other.name_;
      dataType_ = other.dataType_;
      dims_ = other.dims_.Clone();
      reshape_ = other.reshape_ != null ? other.reshape_.Clone() : null;
      labelFilename_ = other.labelFilename_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelOutput Clone() {
      return new ModelOutput(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    ///@@  .. cpp:var:: string name
    ///@@
    ///@@     The name of the output.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "data_type" field.</summary>
    public const int DataTypeFieldNumber = 2;
    private global::Triton.MemoryAnalyzer.Client.DataType dataType_ = 0;
    /// <summary>
    ///@@  .. cpp:var:: DataType data_type
    ///@@
    ///@@     The data-type of the output.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Triton.MemoryAnalyzer.Client.DataType DataType {
      get { return dataType_; }
      set {
        dataType_ = value;
      }
    }

    /// <summary>Field number for the "dims" field.</summary>
    public const int DimsFieldNumber = 3;
    private static readonly pb::FieldCodec<long> _repeated_dims_codec
        = pb::FieldCodec.ForInt64(26);
    private readonly pbc::RepeatedField<long> dims_ = new pbc::RepeatedField<long>();
    /// <summary>
    ///@@  .. cpp:var:: int64 dims (repeated)
    ///@@
    ///@@     The dimensions/shape of the output tensor.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> Dims {
      get { return dims_; }
    }

    /// <summary>Field number for the "reshape" field.</summary>
    public const int ReshapeFieldNumber = 5;
    private global::Triton.MemoryAnalyzer.Client.ModelTensorReshape reshape_;
    /// <summary>
    ///@@  .. cpp:var:: ModelTensorReshape reshape
    ///@@
    ///@@     The shape produced for this output by the backend. The output will
    ///@@     be reshaped from this to the shape specifed in 'dims' before being
    ///@@     returned in the inference response. The reshape must have the same
    ///@@     number of elements as the output shape specified by 'dims'. Optional.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Triton.MemoryAnalyzer.Client.ModelTensorReshape Reshape {
      get { return reshape_; }
      set {
        reshape_ = value;
      }
    }

    /// <summary>Field number for the "label_filename" field.</summary>
    public const int LabelFilenameFieldNumber = 4;
    private string labelFilename_ = "";
    /// <summary>
    ///@@  .. cpp:var:: string label_filename
    ///@@
    ///@@     The label file associated with this output. Should be specified only
    ///@@     for outputs that represent classifications. Optional.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string LabelFilename {
      get { return labelFilename_; }
      set {
        labelFilename_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ModelOutput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ModelOutput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (DataType != other.DataType) return false;
      if(!dims_.Equals(other.dims_)) return false;
      if (!object.Equals(Reshape, other.Reshape)) return false;
      if (LabelFilename != other.LabelFilename) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (DataType != 0) hash ^= DataType.GetHashCode();
      hash ^= dims_.GetHashCode();
      if (reshape_ != null) hash ^= Reshape.GetHashCode();
      if (LabelFilename.Length != 0) hash ^= LabelFilename.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (DataType != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DataType);
      }
      dims_.WriteTo(output, _repeated_dims_codec);
      if (LabelFilename.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(LabelFilename);
      }
      if (reshape_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Reshape);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (DataType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DataType);
      }
      size += dims_.CalculateSize(_repeated_dims_codec);
      if (reshape_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Reshape);
      }
      if (LabelFilename.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LabelFilename);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ModelOutput other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.DataType != 0) {
        DataType = other.DataType;
      }
      dims_.Add(other.dims_);
      if (other.reshape_ != null) {
        if (reshape_ == null) {
          Reshape = new global::Triton.MemoryAnalyzer.Client.ModelTensorReshape();
        }
        Reshape.MergeFrom(other.Reshape);
      }
      if (other.LabelFilename.Length != 0) {
        LabelFilename = other.LabelFilename;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            DataType = (global::Triton.MemoryAnalyzer.Client.DataType) input.ReadEnum();
            break;
          }
          case 26:
          case 24: {
            dims_.AddEntriesFrom(input, _repeated_dims_codec);
            break;
          }
          case 34: {
            LabelFilename = input.ReadString();
            break;
          }
          case 42: {
            if (reshape_ == null) {
              Reshape = new global::Triton.MemoryAnalyzer.Client.ModelTensorReshape();
            }
            input.ReadMessage(Reshape);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelVersionPolicy
  ///@@
  ///@@   Policy indicating which versions of a model should be made
  ///@@   available by the inference server.
  ///@@
  /// </summary>
  public sealed partial class ModelVersionPolicy : pb::IMessage<ModelVersionPolicy> {
    private static readonly pb::MessageParser<ModelVersionPolicy> _parser = new pb::MessageParser<ModelVersionPolicy>(() => new ModelVersionPolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ModelVersionPolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Triton.MemoryAnalyzer.Client.ModelConfigReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelVersionPolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelVersionPolicy(ModelVersionPolicy other) : this() {
      switch (other.PolicyChoiceCase) {
        case PolicyChoiceOneofCase.Latest:
          Latest = other.Latest.Clone();
          break;
        case PolicyChoiceOneofCase.All:
          All = other.All.Clone();
          break;
        case PolicyChoiceOneofCase.Specific:
          Specific = other.Specific.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelVersionPolicy Clone() {
      return new ModelVersionPolicy(this);
    }

    /// <summary>Field number for the "latest" field.</summary>
    public const int LatestFieldNumber = 1;
    /// <summary>
    ///@@    .. cpp:var:: Latest latest
    ///@@
    ///@@       Serve only latest version(s) of the model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.Latest Latest {
      get { return policyChoiceCase_ == PolicyChoiceOneofCase.Latest ? (global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.Latest) policyChoice_ : null; }
      set {
        policyChoice_ = value;
        policyChoiceCase_ = value == null ? PolicyChoiceOneofCase.None : PolicyChoiceOneofCase.Latest;
      }
    }

    /// <summary>Field number for the "all" field.</summary>
    public const int AllFieldNumber = 2;
    /// <summary>
    ///@@    .. cpp:var:: All all
    ///@@
    ///@@       Serve all versions of the model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.All All {
      get { return policyChoiceCase_ == PolicyChoiceOneofCase.All ? (global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.All) policyChoice_ : null; }
      set {
        policyChoice_ = value;
        policyChoiceCase_ = value == null ? PolicyChoiceOneofCase.None : PolicyChoiceOneofCase.All;
      }
    }

    /// <summary>Field number for the "specific" field.</summary>
    public const int SpecificFieldNumber = 3;
    /// <summary>
    ///@@    .. cpp:var:: Specific specific
    ///@@
    ///@@       Serve only specific version(s) of the model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.Specific Specific {
      get { return policyChoiceCase_ == PolicyChoiceOneofCase.Specific ? (global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.Specific) policyChoice_ : null; }
      set {
        policyChoice_ = value;
        policyChoiceCase_ = value == null ? PolicyChoiceOneofCase.None : PolicyChoiceOneofCase.Specific;
      }
    }

    private object policyChoice_;
    /// <summary>Enum of possible cases for the "policy_choice" oneof.</summary>
    public enum PolicyChoiceOneofCase {
      None = 0,
      Latest = 1,
      All = 2,
      Specific = 3,
    }
    private PolicyChoiceOneofCase policyChoiceCase_ = PolicyChoiceOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PolicyChoiceOneofCase PolicyChoiceCase {
      get { return policyChoiceCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPolicyChoice() {
      policyChoiceCase_ = PolicyChoiceOneofCase.None;
      policyChoice_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ModelVersionPolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ModelVersionPolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Latest, other.Latest)) return false;
      if (!object.Equals(All, other.All)) return false;
      if (!object.Equals(Specific, other.Specific)) return false;
      if (PolicyChoiceCase != other.PolicyChoiceCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (policyChoiceCase_ == PolicyChoiceOneofCase.Latest) hash ^= Latest.GetHashCode();
      if (policyChoiceCase_ == PolicyChoiceOneofCase.All) hash ^= All.GetHashCode();
      if (policyChoiceCase_ == PolicyChoiceOneofCase.Specific) hash ^= Specific.GetHashCode();
      hash ^= (int) policyChoiceCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (policyChoiceCase_ == PolicyChoiceOneofCase.Latest) {
        output.WriteRawTag(10);
        output.WriteMessage(Latest);
      }
      if (policyChoiceCase_ == PolicyChoiceOneofCase.All) {
        output.WriteRawTag(18);
        output.WriteMessage(All);
      }
      if (policyChoiceCase_ == PolicyChoiceOneofCase.Specific) {
        output.WriteRawTag(26);
        output.WriteMessage(Specific);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (policyChoiceCase_ == PolicyChoiceOneofCase.Latest) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Latest);
      }
      if (policyChoiceCase_ == PolicyChoiceOneofCase.All) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(All);
      }
      if (policyChoiceCase_ == PolicyChoiceOneofCase.Specific) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Specific);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ModelVersionPolicy other) {
      if (other == null) {
        return;
      }
      switch (other.PolicyChoiceCase) {
        case PolicyChoiceOneofCase.Latest:
          if (Latest == null) {
            Latest = new global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.Latest();
          }
          Latest.MergeFrom(other.Latest);
          break;
        case PolicyChoiceOneofCase.All:
          if (All == null) {
            All = new global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.All();
          }
          All.MergeFrom(other.All);
          break;
        case PolicyChoiceOneofCase.Specific:
          if (Specific == null) {
            Specific = new global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.Specific();
          }
          Specific.MergeFrom(other.Specific);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.Latest subBuilder = new global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.Latest();
            if (policyChoiceCase_ == PolicyChoiceOneofCase.Latest) {
              subBuilder.MergeFrom(Latest);
            }
            input.ReadMessage(subBuilder);
            Latest = subBuilder;
            break;
          }
          case 18: {
            global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.All subBuilder = new global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.All();
            if (policyChoiceCase_ == PolicyChoiceOneofCase.All) {
              subBuilder.MergeFrom(All);
            }
            input.ReadMessage(subBuilder);
            All = subBuilder;
            break;
          }
          case 26: {
            global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.Specific subBuilder = new global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Types.Specific();
            if (policyChoiceCase_ == PolicyChoiceOneofCase.Specific) {
              subBuilder.MergeFrom(Specific);
            }
            input.ReadMessage(subBuilder);
            Specific = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ModelVersionPolicy message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///@@  .. cpp:var:: message Latest
      ///@@
      ///@@     Serve only the latest version(s) of a model. This is
      ///@@     the default policy.
      ///@@
      /// </summary>
      public sealed partial class Latest : pb::IMessage<Latest> {
        private static readonly pb::MessageParser<Latest> _parser = new pb::MessageParser<Latest>(() => new Latest());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Latest> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Latest() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Latest(Latest other) : this() {
          numVersions_ = other.numVersions_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Latest Clone() {
          return new Latest(this);
        }

        /// <summary>Field number for the "num_versions" field.</summary>
        public const int NumVersionsFieldNumber = 1;
        private uint numVersions_;
        /// <summary>
        ///@@    .. cpp:var:: uint32 num_versions
        ///@@
        ///@@       Serve only the 'num_versions' highest-numbered versions. T
        ///@@       The default value of 'num_versions' is 1, indicating that by
        ///@@       default only the single highest-number version of a
        ///@@       model will be served.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint NumVersions {
          get { return numVersions_; }
          set {
            numVersions_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Latest);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Latest other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (NumVersions != other.NumVersions) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (NumVersions != 0) hash ^= NumVersions.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (NumVersions != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(NumVersions);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (NumVersions != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NumVersions);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Latest other) {
          if (other == null) {
            return;
          }
          if (other.NumVersions != 0) {
            NumVersions = other.NumVersions;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                NumVersions = input.ReadUInt32();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      ///@@  .. cpp:var:: message All
      ///@@
      ///@@     Serve all versions of the model.
      ///@@
      /// </summary>
      public sealed partial class All : pb::IMessage<All> {
        private static readonly pb::MessageParser<All> _parser = new pb::MessageParser<All>(() => new All());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<All> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public All() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public All(All other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public All Clone() {
          return new All(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as All);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(All other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(All other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        }

      }

      /// <summary>
      ///@@  .. cpp:var:: message Specific
      ///@@
      ///@@     Serve only specific versions of the model.
      ///@@
      /// </summary>
      public sealed partial class Specific : pb::IMessage<Specific> {
        private static readonly pb::MessageParser<Specific> _parser = new pb::MessageParser<Specific>(() => new Specific());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Specific> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Specific() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Specific(Specific other) : this() {
          versions_ = other.versions_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Specific Clone() {
          return new Specific(this);
        }

        /// <summary>Field number for the "versions" field.</summary>
        public const int VersionsFieldNumber = 1;
        private static readonly pb::FieldCodec<long> _repeated_versions_codec
            = pb::FieldCodec.ForInt64(10);
        private readonly pbc::RepeatedField<long> versions_ = new pbc::RepeatedField<long>();
        /// <summary>
        ///@@    .. cpp:var:: int64 versions (repeated)
        ///@@
        ///@@       The specific versions of the model that will be served.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<long> Versions {
          get { return versions_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Specific);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Specific other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!versions_.Equals(other.versions_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= versions_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          versions_.WriteTo(output, _repeated_versions_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += versions_.CalculateSize(_repeated_versions_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Specific other) {
          if (other == null) {
            return;
          }
          versions_.Add(other.versions_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10:
              case 8: {
                versions_.AddEntriesFrom(input, _repeated_versions_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelOptimizationPolicy
  ///@@
  ///@@   Optimization settings for a model. These settings control if/how a
  ///@@   model is optimized and prioritized by the backend framework when
  ///@@   it is loaded.
  ///@@
  /// </summary>
  public sealed partial class ModelOptimizationPolicy : pb::IMessage<ModelOptimizationPolicy> {
    private static readonly pb::MessageParser<ModelOptimizationPolicy> _parser = new pb::MessageParser<ModelOptimizationPolicy>(() => new ModelOptimizationPolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ModelOptimizationPolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Triton.MemoryAnalyzer.Client.ModelConfigReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelOptimizationPolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelOptimizationPolicy(ModelOptimizationPolicy other) : this() {
      graph_ = other.graph_ != null ? other.graph_.Clone() : null;
      priority_ = other.priority_;
      cuda_ = other.cuda_ != null ? other.cuda_.Clone() : null;
      executionAccelerators_ = other.executionAccelerators_ != null ? other.executionAccelerators_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelOptimizationPolicy Clone() {
      return new ModelOptimizationPolicy(this);
    }

    /// <summary>Field number for the "graph" field.</summary>
    public const int GraphFieldNumber = 1;
    private global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.Graph graph_;
    /// <summary>
    ///@@  .. cpp:var:: Graph graph
    ///@@
    ///@@     The graph optimization setting for the model. Optional.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.Graph Graph {
      get { return graph_; }
      set {
        graph_ = value;
      }
    }

    /// <summary>Field number for the "priority" field.</summary>
    public const int PriorityFieldNumber = 2;
    private global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ModelPriority priority_ = 0;
    /// <summary>
    ///@@  .. cpp:var:: ModelPriority priority
    ///@@
    ///@@     The priority setting for the model. Optional.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ModelPriority Priority {
      get { return priority_; }
      set {
        priority_ = value;
      }
    }

    /// <summary>Field number for the "cuda" field.</summary>
    public const int CudaFieldNumber = 3;
    private global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.Cuda cuda_;
    /// <summary>
    ///@@  .. cpp:var:: Cuda cuda
    ///@@
    ///@@     CUDA-specific optimization settings. Optional.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.Cuda Cuda {
      get { return cuda_; }
      set {
        cuda_ = value;
      }
    }

    /// <summary>Field number for the "execution_accelerators" field.</summary>
    public const int ExecutionAcceleratorsFieldNumber = 4;
    private global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ExecutionAccelerators executionAccelerators_;
    /// <summary>
    ///@@  .. cpp:var:: ExecutionAccelerators execution_accelerators
    ///@@
    ///@@     The accelerators used for the model. Optional.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ExecutionAccelerators ExecutionAccelerators {
      get { return executionAccelerators_; }
      set {
        executionAccelerators_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ModelOptimizationPolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ModelOptimizationPolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Graph, other.Graph)) return false;
      if (Priority != other.Priority) return false;
      if (!object.Equals(Cuda, other.Cuda)) return false;
      if (!object.Equals(ExecutionAccelerators, other.ExecutionAccelerators)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (graph_ != null) hash ^= Graph.GetHashCode();
      if (Priority != 0) hash ^= Priority.GetHashCode();
      if (cuda_ != null) hash ^= Cuda.GetHashCode();
      if (executionAccelerators_ != null) hash ^= ExecutionAccelerators.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (graph_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Graph);
      }
      if (Priority != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Priority);
      }
      if (cuda_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Cuda);
      }
      if (executionAccelerators_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ExecutionAccelerators);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (graph_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Graph);
      }
      if (Priority != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Priority);
      }
      if (cuda_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Cuda);
      }
      if (executionAccelerators_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExecutionAccelerators);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ModelOptimizationPolicy other) {
      if (other == null) {
        return;
      }
      if (other.graph_ != null) {
        if (graph_ == null) {
          Graph = new global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.Graph();
        }
        Graph.MergeFrom(other.Graph);
      }
      if (other.Priority != 0) {
        Priority = other.Priority;
      }
      if (other.cuda_ != null) {
        if (cuda_ == null) {
          Cuda = new global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.Cuda();
        }
        Cuda.MergeFrom(other.Cuda);
      }
      if (other.executionAccelerators_ != null) {
        if (executionAccelerators_ == null) {
          ExecutionAccelerators = new global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ExecutionAccelerators();
        }
        ExecutionAccelerators.MergeFrom(other.ExecutionAccelerators);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (graph_ == null) {
              Graph = new global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.Graph();
            }
            input.ReadMessage(Graph);
            break;
          }
          case 16: {
            Priority = (global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ModelPriority) input.ReadEnum();
            break;
          }
          case 26: {
            if (cuda_ == null) {
              Cuda = new global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.Cuda();
            }
            input.ReadMessage(Cuda);
            break;
          }
          case 34: {
            if (executionAccelerators_ == null) {
              ExecutionAccelerators = new global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ExecutionAccelerators();
            }
            input.ReadMessage(ExecutionAccelerators);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ModelOptimizationPolicy message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///@@
      ///@@  .. cpp:enum:: ModelPriority
      ///@@
      ///@@     Model priorities. A model will be given scheduling and execution
      ///@@     preference over models at lower priorities. Current model
      ///@@     priorities only work for TensorRT models.
      ///@@
      /// </summary>
      public enum ModelPriority {
        /// <summary>
        ///@@    .. cpp:enumerator:: ModelPriority::PRIORITY_DEFAULT = 0
        ///@@
        ///@@       The default model priority.
        ///@@
        /// </summary>
        [pbr::OriginalName("PRIORITY_DEFAULT")] PriorityDefault = 0,
        /// <summary>
        ///@@    .. cpp:enumerator:: ModelPriority::PRIORITY_MAX = 1
        ///@@
        ///@@       The maximum model priority.
        ///@@
        /// </summary>
        [pbr::OriginalName("PRIORITY_MAX")] PriorityMax = 1,
        /// <summary>
        ///@@    .. cpp:enumerator:: ModelPriority::PRIORITY_MIN = 2
        ///@@
        ///@@       The minimum model priority.
        ///@@
        /// </summary>
        [pbr::OriginalName("PRIORITY_MIN")] PriorityMin = 2,
      }

      /// <summary>
      ///@@
      ///@@  .. cpp:var:: message Graph
      ///@@
      ///@@     Enable generic graph optimization of the model. If not specified
      ///@@     the framework's default level of optimization is used. Currently
      ///@@     only supported for TensorFlow graphdef and savedmodel models and
      ///@@     causes XLA to be enabled/disabled for the model.
      ///@@
      /// </summary>
      public sealed partial class Graph : pb::IMessage<Graph> {
        private static readonly pb::MessageParser<Graph> _parser = new pb::MessageParser<Graph>(() => new Graph());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Graph> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Graph() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Graph(Graph other) : this() {
          level_ = other.level_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Graph Clone() {
          return new Graph(this);
        }

        /// <summary>Field number for the "level" field.</summary>
        public const int LevelFieldNumber = 1;
        private int level_;
        /// <summary>
        ///@@    .. cpp:var:: int32 level
        ///@@
        ///@@       The optimization level. Defaults to 0 (zero) if not specified.
        ///@@
        ///@@         - -1: Disabled
        ///@@         -  0: Framework default
        ///@@         -  1+: Enable optimization level (greater values indicate
        ///@@            higher optimization levels)
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int Level {
          get { return level_; }
          set {
            level_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Graph);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Graph other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Level != other.Level) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Level != 0) hash ^= Level.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Level != 0) {
            output.WriteRawTag(8);
            output.WriteInt32(Level);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Level != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(Level);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Graph other) {
          if (other == null) {
            return;
          }
          if (other.Level != 0) {
            Level = other.Level;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Level = input.ReadInt32();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      ///@@
      ///@@  .. cpp:var:: message Cuda
      ///@@
      ///@@     CUDA-specific optimization settings.
      ///@@
      /// </summary>
      public sealed partial class Cuda : pb::IMessage<Cuda> {
        private static readonly pb::MessageParser<Cuda> _parser = new pb::MessageParser<Cuda>(() => new Cuda());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Cuda> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Cuda() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Cuda(Cuda other) : this() {
          graphs_ = other.graphs_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Cuda Clone() {
          return new Cuda(this);
        }

        /// <summary>Field number for the "graphs" field.</summary>
        public const int GraphsFieldNumber = 1;
        private bool graphs_;
        /// <summary>
        ///@@    .. cpp:var:: bool graphs
        ///@@
        ///@@       Use CUDA graphs API to capture model operations and execute
        ///@@       them more efficiently. Currently only recognized by TensorRT
        ///@@       backend.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Graphs {
          get { return graphs_; }
          set {
            graphs_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Cuda);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Cuda other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Graphs != other.Graphs) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Graphs != false) hash ^= Graphs.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Graphs != false) {
            output.WriteRawTag(8);
            output.WriteBool(Graphs);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Graphs != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Cuda other) {
          if (other == null) {
            return;
          }
          if (other.Graphs != false) {
            Graphs = other.Graphs;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Graphs = input.ReadBool();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      ///@@
      ///@@  .. cpp:var:: message ExecutionAccelerators
      ///@@
      ///@@     Specify the preferred execution accelerators to be used to execute
      ///@@     the model. Currently only recognized by ONNX Runtime backend and
      ///@@     TensorFlow backend.
      ///@@
      ///@@     For ONNX Runtime backend, it will deploy the model with the execution
      ///@@     accelerators by priority, the priority is determined based on the
      ///@@     order that they are set, i.e. the provider at the front has highest
      ///@@     priority. Overall, the priority will be in the following order:
      ///@@         &lt;gpu_execution_accelerator> (if instance is on GPU)
      ///@@         CUDA Execution Provider     (if instance is on GPU)
      ///@@         &lt;cpu_execution_accelerator>
      ///@@         Default CPU Execution Provider
      ///@@
      /// </summary>
      public sealed partial class ExecutionAccelerators : pb::IMessage<ExecutionAccelerators> {
        private static readonly pb::MessageParser<ExecutionAccelerators> _parser = new pb::MessageParser<ExecutionAccelerators>(() => new ExecutionAccelerators());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ExecutionAccelerators> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ExecutionAccelerators() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ExecutionAccelerators(ExecutionAccelerators other) : this() {
          gpuExecutionAccelerator_ = other.gpuExecutionAccelerator_.Clone();
          cpuExecutionAccelerator_ = other.cpuExecutionAccelerator_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ExecutionAccelerators Clone() {
          return new ExecutionAccelerators(this);
        }

        /// <summary>Field number for the "gpu_execution_accelerator" field.</summary>
        public const int GpuExecutionAcceleratorFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator> _repeated_gpuExecutionAccelerator_codec
            = pb::FieldCodec.ForMessage(10, global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator.Parser);
        private readonly pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator> gpuExecutionAccelerator_ = new pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator>();
        /// <summary>
        ///@@    .. cpp:var:: Accelerator gpu_execution_accelerator (repeated)
        ///@@
        ///@@       The preferred execution provider to be used if the model instance
        ///@@       is deployed on GPU.
        ///@@
        ///@@       For ONNX Runtime backend, possible value is "tensorrt" as name,
        ///@@       and no parameters are required.
        ///@@
        ///@@       For TensorFlow backend, possible values are "tensorrt", "gpu_io".
        ///@@
        ///@@       For "tensorrt", the following parameters can be specified:
        ///@@         "precision_mode": The precision used for optimization.
        ///@@         Allowed values are "FP32" and "FP16". Default value is "FP32".
        ///@@
        ///@@         "max_cached_engines": The maximum number of cached TensorRT
        ///@@         engines in dynamic TensorRT ops. Default value is 100.
        ///@@
        ///@@         "minimum_segment_size": The smallest model subgraph that will
        ///@@         be considered for optimization by TensorRT. Default value is 3.
        ///@@
        ///@@         "max_workspace_size_bytes": The maximum GPU memory the model
        ///@@         can use temporarily during execution. Default value is 1GB.
        ///@@
        ///@@       For "gpu_io", no parameters are required. If set, the model will
        ///@@       be executed using TensorFlow Callable API to set input and output
        ///@@       tensors in GPU memory if possible, which can reduce data transfer
        ///@@       overhead if the model is used in ensemble. However, the Callable
        ///@@       object will be created on model creation and it will request all
        ///@@       outputs for every model execution, which may impact the
        ///@@       performance if a request does not require all outputs. This
        ///@@       optimization will only take affect if the model instance is
        ///@@       created with KIND_GPU.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator> GpuExecutionAccelerator {
          get { return gpuExecutionAccelerator_; }
        }

        /// <summary>Field number for the "cpu_execution_accelerator" field.</summary>
        public const int CpuExecutionAcceleratorFieldNumber = 2;
        private static readonly pb::FieldCodec<global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator> _repeated_cpuExecutionAccelerator_codec
            = pb::FieldCodec.ForMessage(18, global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator.Parser);
        private readonly pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator> cpuExecutionAccelerator_ = new pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator>();
        /// <summary>
        ///@@    .. cpp:var:: Accelerator cpu_execution_accelerator (repeated)
        ///@@
        ///@@       The preferred execution provider to be used if the model instance
        ///@@       is deployed on CPU.
        ///@@
        ///@@       For ONNX Runtime backend, possible value is "openvino" as name,
        ///@@       and no parameters are required.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator> CpuExecutionAccelerator {
          get { return cpuExecutionAccelerator_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as ExecutionAccelerators);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ExecutionAccelerators other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!gpuExecutionAccelerator_.Equals(other.gpuExecutionAccelerator_)) return false;
          if(!cpuExecutionAccelerator_.Equals(other.cpuExecutionAccelerator_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= gpuExecutionAccelerator_.GetHashCode();
          hash ^= cpuExecutionAccelerator_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          gpuExecutionAccelerator_.WriteTo(output, _repeated_gpuExecutionAccelerator_codec);
          cpuExecutionAccelerator_.WriteTo(output, _repeated_cpuExecutionAccelerator_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += gpuExecutionAccelerator_.CalculateSize(_repeated_gpuExecutionAccelerator_codec);
          size += cpuExecutionAccelerator_.CalculateSize(_repeated_cpuExecutionAccelerator_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ExecutionAccelerators other) {
          if (other == null) {
            return;
          }
          gpuExecutionAccelerator_.Add(other.gpuExecutionAccelerator_);
          cpuExecutionAccelerator_.Add(other.cpuExecutionAccelerator_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                gpuExecutionAccelerator_.AddEntriesFrom(input, _repeated_gpuExecutionAccelerator_codec);
                break;
              }
              case 18: {
                cpuExecutionAccelerator_.AddEntriesFrom(input, _repeated_cpuExecutionAccelerator_codec);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the ExecutionAccelerators message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          ///@@
          ///@@  .. cpp:var:: message Accelerator
          ///@@
          ///@@     Specify the accelerator to be used to execute the model.
          ///@@     Accelerator with the same name may accept different parameters
          ///@@     depending on the backends.
          ///@@
          /// </summary>
          public sealed partial class Accelerator : pb::IMessage<Accelerator> {
            private static readonly pb::MessageParser<Accelerator> _parser = new pb::MessageParser<Accelerator>(() => new Accelerator());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<Accelerator> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy.Types.ExecutionAccelerators.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Accelerator() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Accelerator(Accelerator other) : this() {
              name_ = other.name_;
              parameters_ = other.parameters_.Clone();
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Accelerator Clone() {
              return new Accelerator(this);
            }

            /// <summary>Field number for the "name" field.</summary>
            public const int NameFieldNumber = 1;
            private string name_ = "";
            /// <summary>
            ///@@    .. cpp:var:: string name
            ///@@
            ///@@       The name of the execution accelerator.
            ///@@
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string Name {
              get { return name_; }
              set {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "parameters" field.</summary>
            public const int ParametersFieldNumber = 2;
            private static readonly pbc::MapField<string, string>.Codec _map_parameters_codec
                = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 18);
            private readonly pbc::MapField<string, string> parameters_ = new pbc::MapField<string, string>();
            /// <summary>
            ///@@    .. cpp:var:: map&lt;string, string> parameters
            ///@@
            ///@@       Additional paremeters used to configure the accelerator.
            ///@@
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::MapField<string, string> Parameters {
              get { return parameters_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as Accelerator);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(Accelerator other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Name != other.Name) return false;
              if (!Parameters.Equals(other.Parameters)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (Name.Length != 0) hash ^= Name.GetHashCode();
              hash ^= Parameters.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (Name.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(Name);
              }
              parameters_.WriteTo(output, _map_parameters_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (Name.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
              }
              size += parameters_.CalculateSize(_map_parameters_codec);
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(Accelerator other) {
              if (other == null) {
                return;
              }
              if (other.Name.Length != 0) {
                Name = other.Name;
              }
              parameters_.Add(other.parameters_);
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    Name = input.ReadString();
                    break;
                  }
                  case 18: {
                    parameters_.AddEntriesFrom(input, _map_parameters_codec);
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelDynamicBatching
  ///@@
  ///@@   Dynamic batching configuration. These settings control how dynamic
  ///@@   batching operates for the model.
  ///@@
  /// </summary>
  public sealed partial class ModelDynamicBatching : pb::IMessage<ModelDynamicBatching> {
    private static readonly pb::MessageParser<ModelDynamicBatching> _parser = new pb::MessageParser<ModelDynamicBatching>(() => new ModelDynamicBatching());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ModelDynamicBatching> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Triton.MemoryAnalyzer.Client.ModelConfigReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelDynamicBatching() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelDynamicBatching(ModelDynamicBatching other) : this() {
      preferredBatchSize_ = other.preferredBatchSize_.Clone();
      maxQueueDelayMicroseconds_ = other.maxQueueDelayMicroseconds_;
      preserveOrdering_ = other.preserveOrdering_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelDynamicBatching Clone() {
      return new ModelDynamicBatching(this);
    }

    /// <summary>Field number for the "preferred_batch_size" field.</summary>
    public const int PreferredBatchSizeFieldNumber = 1;
    private static readonly pb::FieldCodec<int> _repeated_preferredBatchSize_codec
        = pb::FieldCodec.ForInt32(10);
    private readonly pbc::RepeatedField<int> preferredBatchSize_ = new pbc::RepeatedField<int>();
    /// <summary>
    ///@@  .. cpp:var:: int32 preferred_batch_size (repeated)
    ///@@
    ///@@     Preferred batch sizes for dynamic batching. If a batch of one of
    ///@@     these sizes can be formed it will be executed immediately.  If
    ///@@     not specified a preferred batch size will be chosen automatically
    ///@@     based on model and GPU characteristics.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> PreferredBatchSize {
      get { return preferredBatchSize_; }
    }

    /// <summary>Field number for the "max_queue_delay_microseconds" field.</summary>
    public const int MaxQueueDelayMicrosecondsFieldNumber = 2;
    private ulong maxQueueDelayMicroseconds_;
    /// <summary>
    ///@@  .. cpp:var:: uint64 max_queue_delay_microseconds
    ///@@
    ///@@     The maximum time, in microseconds, a request will be delayed in
    ///@@     the scheduling queue to wait for additional requests for
    ///@@     batching. Default is 0.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong MaxQueueDelayMicroseconds {
      get { return maxQueueDelayMicroseconds_; }
      set {
        maxQueueDelayMicroseconds_ = value;
      }
    }

    /// <summary>Field number for the "preserve_ordering" field.</summary>
    public const int PreserveOrderingFieldNumber = 3;
    private bool preserveOrdering_;
    /// <summary>
    ///@@  .. cpp:var:: bool preserve_ordering
    ///@@
    ///@@     Should the dynamic batcher preserve the ordering of responses to
    ///@@     match the order of requests received by the scheduler. Default is
    ///@@     false. If true, the responses will be returned in the same order as
    ///@@     the order of requests sent to the scheduler. If false, the responses
    ///@@     may be returned in arbitrary order. This option is specifically
    ///@@     needed when a sequence of related inference requests (i.e. inference
    ///@@     requests with the same correlation ID) are sent to the dynamic
    ///@@     batcher to ensure that the sequence responses are in the correct
    ///@@     order.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool PreserveOrdering {
      get { return preserveOrdering_; }
      set {
        preserveOrdering_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ModelDynamicBatching);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ModelDynamicBatching other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!preferredBatchSize_.Equals(other.preferredBatchSize_)) return false;
      if (MaxQueueDelayMicroseconds != other.MaxQueueDelayMicroseconds) return false;
      if (PreserveOrdering != other.PreserveOrdering) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= preferredBatchSize_.GetHashCode();
      if (MaxQueueDelayMicroseconds != 0UL) hash ^= MaxQueueDelayMicroseconds.GetHashCode();
      if (PreserveOrdering != false) hash ^= PreserveOrdering.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      preferredBatchSize_.WriteTo(output, _repeated_preferredBatchSize_codec);
      if (MaxQueueDelayMicroseconds != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(MaxQueueDelayMicroseconds);
      }
      if (PreserveOrdering != false) {
        output.WriteRawTag(24);
        output.WriteBool(PreserveOrdering);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += preferredBatchSize_.CalculateSize(_repeated_preferredBatchSize_codec);
      if (MaxQueueDelayMicroseconds != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MaxQueueDelayMicroseconds);
      }
      if (PreserveOrdering != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ModelDynamicBatching other) {
      if (other == null) {
        return;
      }
      preferredBatchSize_.Add(other.preferredBatchSize_);
      if (other.MaxQueueDelayMicroseconds != 0UL) {
        MaxQueueDelayMicroseconds = other.MaxQueueDelayMicroseconds;
      }
      if (other.PreserveOrdering != false) {
        PreserveOrdering = other.PreserveOrdering;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            preferredBatchSize_.AddEntriesFrom(input, _repeated_preferredBatchSize_codec);
            break;
          }
          case 16: {
            MaxQueueDelayMicroseconds = input.ReadUInt64();
            break;
          }
          case 24: {
            PreserveOrdering = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelSequenceBatching
  ///@@
  ///@@   Sequence batching configuration. These settings control how sequence
  ///@@   batching operates for the model.
  ///@@
  /// </summary>
  public sealed partial class ModelSequenceBatching : pb::IMessage<ModelSequenceBatching> {
    private static readonly pb::MessageParser<ModelSequenceBatching> _parser = new pb::MessageParser<ModelSequenceBatching>(() => new ModelSequenceBatching());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ModelSequenceBatching> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Triton.MemoryAnalyzer.Client.ModelConfigReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelSequenceBatching() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelSequenceBatching(ModelSequenceBatching other) : this() {
      maxSequenceIdleMicroseconds_ = other.maxSequenceIdleMicroseconds_;
      controlInput_ = other.controlInput_.Clone();
      switch (other.StrategyChoiceCase) {
        case StrategyChoiceOneofCase.Direct:
          Direct = other.Direct.Clone();
          break;
        case StrategyChoiceOneofCase.Oldest:
          Oldest = other.Oldest.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelSequenceBatching Clone() {
      return new ModelSequenceBatching(this);
    }

    /// <summary>Field number for the "direct" field.</summary>
    public const int DirectFieldNumber = 3;
    /// <summary>
    ///@@    .. cpp:var:: StrategyDirect direct
    ///@@
    ///@@       StrategyDirect scheduling strategy.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.StrategyDirect Direct {
      get { return strategyChoiceCase_ == StrategyChoiceOneofCase.Direct ? (global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.StrategyDirect) strategyChoice_ : null; }
      set {
        strategyChoice_ = value;
        strategyChoiceCase_ = value == null ? StrategyChoiceOneofCase.None : StrategyChoiceOneofCase.Direct;
      }
    }

    /// <summary>Field number for the "oldest" field.</summary>
    public const int OldestFieldNumber = 4;
    /// <summary>
    ///@@    .. cpp:var:: StrategyOldest oldest
    ///@@
    ///@@       StrategyOldest scheduling strategy.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.StrategyOldest Oldest {
      get { return strategyChoiceCase_ == StrategyChoiceOneofCase.Oldest ? (global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.StrategyOldest) strategyChoice_ : null; }
      set {
        strategyChoice_ = value;
        strategyChoiceCase_ = value == null ? StrategyChoiceOneofCase.None : StrategyChoiceOneofCase.Oldest;
      }
    }

    /// <summary>Field number for the "max_sequence_idle_microseconds" field.</summary>
    public const int MaxSequenceIdleMicrosecondsFieldNumber = 1;
    private ulong maxSequenceIdleMicroseconds_;
    /// <summary>
    ///@@  .. cpp:var:: uint64 max_sequence_idle_microseconds
    ///@@
    ///@@     The maximum time, in microseconds, that a sequence is allowed to
    ///@@     be idle before it is aborted. The inference server considers a
    ///@@     sequence idle when it does not have any inference request queued
    ///@@     for the sequence. If this limit is exceeded, the inference server
    ///@@     will free the sequence slot allocated by the sequence and make it
    ///@@     available for another sequence. If not specified (or specified as
    ///@@     zero) a default value of 1000000 (1 second) is used.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong MaxSequenceIdleMicroseconds {
      get { return maxSequenceIdleMicroseconds_; }
      set {
        maxSequenceIdleMicroseconds_ = value;
      }
    }

    /// <summary>Field number for the "control_input" field.</summary>
    public const int ControlInputFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.ControlInput> _repeated_controlInput_codec
        = pb::FieldCodec.ForMessage(18, global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.ControlInput.Parser);
    private readonly pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.ControlInput> controlInput_ = new pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.ControlInput>();
    /// <summary>
    ///@@  .. cpp:var:: ControlInput control_input (repeated)
    ///@@
    ///@@     The model input(s) that the server should use to communicate
    ///@@     sequence start, stop, ready and similar control values to the
    ///@@     model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.ControlInput> ControlInput {
      get { return controlInput_; }
    }

    private object strategyChoice_;
    /// <summary>Enum of possible cases for the "strategy_choice" oneof.</summary>
    public enum StrategyChoiceOneofCase {
      None = 0,
      Direct = 3,
      Oldest = 4,
    }
    private StrategyChoiceOneofCase strategyChoiceCase_ = StrategyChoiceOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StrategyChoiceOneofCase StrategyChoiceCase {
      get { return strategyChoiceCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStrategyChoice() {
      strategyChoiceCase_ = StrategyChoiceOneofCase.None;
      strategyChoice_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ModelSequenceBatching);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ModelSequenceBatching other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Direct, other.Direct)) return false;
      if (!object.Equals(Oldest, other.Oldest)) return false;
      if (MaxSequenceIdleMicroseconds != other.MaxSequenceIdleMicroseconds) return false;
      if(!controlInput_.Equals(other.controlInput_)) return false;
      if (StrategyChoiceCase != other.StrategyChoiceCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (strategyChoiceCase_ == StrategyChoiceOneofCase.Direct) hash ^= Direct.GetHashCode();
      if (strategyChoiceCase_ == StrategyChoiceOneofCase.Oldest) hash ^= Oldest.GetHashCode();
      if (MaxSequenceIdleMicroseconds != 0UL) hash ^= MaxSequenceIdleMicroseconds.GetHashCode();
      hash ^= controlInput_.GetHashCode();
      hash ^= (int) strategyChoiceCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MaxSequenceIdleMicroseconds != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(MaxSequenceIdleMicroseconds);
      }
      controlInput_.WriteTo(output, _repeated_controlInput_codec);
      if (strategyChoiceCase_ == StrategyChoiceOneofCase.Direct) {
        output.WriteRawTag(26);
        output.WriteMessage(Direct);
      }
      if (strategyChoiceCase_ == StrategyChoiceOneofCase.Oldest) {
        output.WriteRawTag(34);
        output.WriteMessage(Oldest);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (strategyChoiceCase_ == StrategyChoiceOneofCase.Direct) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Direct);
      }
      if (strategyChoiceCase_ == StrategyChoiceOneofCase.Oldest) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Oldest);
      }
      if (MaxSequenceIdleMicroseconds != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MaxSequenceIdleMicroseconds);
      }
      size += controlInput_.CalculateSize(_repeated_controlInput_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ModelSequenceBatching other) {
      if (other == null) {
        return;
      }
      if (other.MaxSequenceIdleMicroseconds != 0UL) {
        MaxSequenceIdleMicroseconds = other.MaxSequenceIdleMicroseconds;
      }
      controlInput_.Add(other.controlInput_);
      switch (other.StrategyChoiceCase) {
        case StrategyChoiceOneofCase.Direct:
          if (Direct == null) {
            Direct = new global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.StrategyDirect();
          }
          Direct.MergeFrom(other.Direct);
          break;
        case StrategyChoiceOneofCase.Oldest:
          if (Oldest == null) {
            Oldest = new global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.StrategyOldest();
          }
          Oldest.MergeFrom(other.Oldest);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            MaxSequenceIdleMicroseconds = input.ReadUInt64();
            break;
          }
          case 18: {
            controlInput_.AddEntriesFrom(input, _repeated_controlInput_codec);
            break;
          }
          case 26: {
            global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.StrategyDirect subBuilder = new global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.StrategyDirect();
            if (strategyChoiceCase_ == StrategyChoiceOneofCase.Direct) {
              subBuilder.MergeFrom(Direct);
            }
            input.ReadMessage(subBuilder);
            Direct = subBuilder;
            break;
          }
          case 34: {
            global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.StrategyOldest subBuilder = new global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.StrategyOldest();
            if (strategyChoiceCase_ == StrategyChoiceOneofCase.Oldest) {
              subBuilder.MergeFrom(Oldest);
            }
            input.ReadMessage(subBuilder);
            Oldest = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ModelSequenceBatching message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///@@  .. cpp:var:: message Control
      ///@@
      ///@@     A control is a signal that the sequence batcher uses to
      ///@@     communicate with a backend.
      ///@@
      /// </summary>
      public sealed partial class Control : pb::IMessage<Control> {
        private static readonly pb::MessageParser<Control> _parser = new pb::MessageParser<Control>(() => new Control());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Control> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Control() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Control(Control other) : this() {
          kind_ = other.kind_;
          int32FalseTrue_ = other.int32FalseTrue_.Clone();
          fp32FalseTrue_ = other.fp32FalseTrue_.Clone();
          dataType_ = other.dataType_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Control Clone() {
          return new Control(this);
        }

        /// <summary>Field number for the "kind" field.</summary>
        public const int KindFieldNumber = 1;
        private global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.Control.Types.Kind kind_ = 0;
        /// <summary>
        ///@@    .. cpp:var:: Kind kind
        ///@@
        ///@@       The kind of this control.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.Control.Types.Kind Kind {
          get { return kind_; }
          set {
            kind_ = value;
          }
        }

        /// <summary>Field number for the "int32_false_true" field.</summary>
        public const int Int32FalseTrueFieldNumber = 2;
        private static readonly pb::FieldCodec<int> _repeated_int32FalseTrue_codec
            = pb::FieldCodec.ForInt32(18);
        private readonly pbc::RepeatedField<int> int32FalseTrue_ = new pbc::RepeatedField<int>();
        /// <summary>
        ///@@    .. cpp:var:: int32 int32_false_true (repeated)
        ///@@
        ///@@       The control's true and false setting is indicated by setting
        ///@@       a value in an int32 tensor. The tensor must be a
        ///@@       1-dimensional tensor with size equal to the batch size of
        ///@@       the request. 'int32_false_true' must have two entries: the
        ///@@       first the false value and the second the true value.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<int> Int32FalseTrue {
          get { return int32FalseTrue_; }
        }

        /// <summary>Field number for the "fp32_false_true" field.</summary>
        public const int Fp32FalseTrueFieldNumber = 3;
        private static readonly pb::FieldCodec<float> _repeated_fp32FalseTrue_codec
            = pb::FieldCodec.ForFloat(26);
        private readonly pbc::RepeatedField<float> fp32FalseTrue_ = new pbc::RepeatedField<float>();
        /// <summary>
        ///@@    .. cpp:var:: float fp32_false_true (repeated)
        ///@@
        ///@@       The control's true and false setting is indicated by setting
        ///@@       a value in a fp32 tensor. The tensor must be a
        ///@@       1-dimensional tensor with size equal to the batch size of
        ///@@       the request. 'fp32_false_true' must have two entries: the
        ///@@       first the false value and the second the true value.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<float> Fp32FalseTrue {
          get { return fp32FalseTrue_; }
        }

        /// <summary>Field number for the "data_type" field.</summary>
        public const int DataTypeFieldNumber = 4;
        private global::Triton.MemoryAnalyzer.Client.DataType dataType_ = 0;
        /// <summary>
        ///@@    .. cpp:var:: DataType data_type
        ///@@
        ///@@       The control's datatype.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Triton.MemoryAnalyzer.Client.DataType DataType {
          get { return dataType_; }
          set {
            dataType_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Control);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Control other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Kind != other.Kind) return false;
          if(!int32FalseTrue_.Equals(other.int32FalseTrue_)) return false;
          if(!fp32FalseTrue_.Equals(other.fp32FalseTrue_)) return false;
          if (DataType != other.DataType) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Kind != 0) hash ^= Kind.GetHashCode();
          hash ^= int32FalseTrue_.GetHashCode();
          hash ^= fp32FalseTrue_.GetHashCode();
          if (DataType != 0) hash ^= DataType.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Kind != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Kind);
          }
          int32FalseTrue_.WriteTo(output, _repeated_int32FalseTrue_codec);
          fp32FalseTrue_.WriteTo(output, _repeated_fp32FalseTrue_codec);
          if (DataType != 0) {
            output.WriteRawTag(32);
            output.WriteEnum((int) DataType);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Kind != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Kind);
          }
          size += int32FalseTrue_.CalculateSize(_repeated_int32FalseTrue_codec);
          size += fp32FalseTrue_.CalculateSize(_repeated_fp32FalseTrue_codec);
          if (DataType != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DataType);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Control other) {
          if (other == null) {
            return;
          }
          if (other.Kind != 0) {
            Kind = other.Kind;
          }
          int32FalseTrue_.Add(other.int32FalseTrue_);
          fp32FalseTrue_.Add(other.fp32FalseTrue_);
          if (other.DataType != 0) {
            DataType = other.DataType;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Kind = (global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.Control.Types.Kind) input.ReadEnum();
                break;
              }
              case 18:
              case 16: {
                int32FalseTrue_.AddEntriesFrom(input, _repeated_int32FalseTrue_codec);
                break;
              }
              case 26:
              case 29: {
                fp32FalseTrue_.AddEntriesFrom(input, _repeated_fp32FalseTrue_codec);
                break;
              }
              case 32: {
                DataType = (global::Triton.MemoryAnalyzer.Client.DataType) input.ReadEnum();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Control message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          ///@@
          ///@@    .. cpp:enum:: Kind
          ///@@
          ///@@       The kind of the control.
          ///@@
          /// </summary>
          public enum Kind {
            /// <summary>
            ///@@      .. cpp:enumerator:: Kind::CONTROL_SEQUENCE_START = 0
            ///@@
            ///@@         A new sequence is/is-not starting. If true a sequence is
            ///@@         starting, if false a sequence is continuing. Must
            ///@@         specify either int32_false_true or fp32_false_true for
            ///@@         this control. This control is optional.
            ///@@
            /// </summary>
            [pbr::OriginalName("CONTROL_SEQUENCE_START")] ControlSequenceStart = 0,
            /// <summary>
            ///@@      .. cpp:enumerator:: Kind::CONTROL_SEQUENCE_READY = 1
            ///@@
            ///@@         A sequence is/is-not ready for inference. If true the
            ///@@         input tensor data is valid and should be used. If false
            ///@@         the input tensor data is invalid and inferencing should
            ///@@         be "skipped".  Must specify either int32_false_true or
            ///@@         fp32_false_true for this control. This control is optional.
            ///@@
            /// </summary>
            [pbr::OriginalName("CONTROL_SEQUENCE_READY")] ControlSequenceReady = 1,
            /// <summary>
            ///@@      .. cpp:enumerator:: Kind::CONTROL_SEQUENCE_END = 2
            ///@@
            ///@@         A sequence is/is-not ending. If true a sequence is
            ///@@         ending, if false a sequence is continuing. Must
            ///@@         specify either int32_false_true or fp32_false_true for
            ///@@         this control. This control is optional.
            ///@@
            /// </summary>
            [pbr::OriginalName("CONTROL_SEQUENCE_END")] ControlSequenceEnd = 2,
            /// <summary>
            ///@@      .. cpp:enumerator:: Kind::CONTROL_SEQUENCE_CORRID = 3
            ///@@
            ///@@         The correlation ID of the sequence. The correlation ID
            ///@@         is an uint64_t value that is communicated in whole or
            ///@@         in part by the tensor. The tensor's datatype must be
            ///@@         specified by data_type and must be TYPE_UINT64, TYPE_INT64,
            ///@@         TYPE_UINT32 or TYPE_INT32. If a 32-bit datatype is specified
            ///@@         the correlation ID will be truncated to the low-order 32
            ///@@         bits. This control is optional.
            ///@@
            /// </summary>
            [pbr::OriginalName("CONTROL_SEQUENCE_CORRID")] ControlSequenceCorrid = 3,
          }

        }
        #endregion

      }

      /// <summary>
      ///@@  .. cpp:var:: message ControlInput
      ///@@
      ///@@     The sequence control values to communicate by a model input.
      ///@@
      /// </summary>
      public sealed partial class ControlInput : pb::IMessage<ControlInput> {
        private static readonly pb::MessageParser<ControlInput> _parser = new pb::MessageParser<ControlInput>(() => new ControlInput());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ControlInput> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ControlInput() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ControlInput(ControlInput other) : this() {
          name_ = other.name_;
          control_ = other.control_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ControlInput Clone() {
          return new ControlInput(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        ///@@    .. cpp:var:: string name
        ///@@
        ///@@       The name of the model input.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "control" field.</summary>
        public const int ControlFieldNumber = 2;
        private static readonly pb::FieldCodec<global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.Control> _repeated_control_codec
            = pb::FieldCodec.ForMessage(18, global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.Control.Parser);
        private readonly pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.Control> control_ = new pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.Control>();
        /// <summary>
        ///@@    .. cpp:var:: Control control (repeated)
        ///@@
        ///@@       The control value(s) that should be communicated to the
        ///@@       model using this model input.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Types.Control> Control {
          get { return control_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as ControlInput);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ControlInput other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if(!control_.Equals(other.control_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          hash ^= control_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          control_.WriteTo(output, _repeated_control_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          size += control_.CalculateSize(_repeated_control_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ControlInput other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          control_.Add(other.control_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                control_.AddEntriesFrom(input, _repeated_control_codec);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      ///@@  .. cpp:var:: message StrategyDirect
      ///@@
      ///@@     The sequence batcher uses a specific, unique batch
      ///@@     slot for each sequence. All inference requests in a
      ///@@     sequence are directed to the same batch slot in the same
      ///@@     model instance over the lifetime of the sequence. This
      ///@@     is the default strategy.
      ///@@
      /// </summary>
      public sealed partial class StrategyDirect : pb::IMessage<StrategyDirect> {
        private static readonly pb::MessageParser<StrategyDirect> _parser = new pb::MessageParser<StrategyDirect>(() => new StrategyDirect());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<StrategyDirect> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public StrategyDirect() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public StrategyDirect(StrategyDirect other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public StrategyDirect Clone() {
          return new StrategyDirect(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as StrategyDirect);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(StrategyDirect other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(StrategyDirect other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        }

      }

      /// <summary>
      ///@@  .. cpp:var:: message StrategyOldest
      ///@@
      ///@@     The sequence batcher maintains up to 'max_candidate_sequences'
      ///@@     candidate sequences. 'max_candidate_sequences' can be greater
      ///@@     than the model's 'max_batch_size'. For inferencing the batcher
      ///@@     chooses from the candidate sequences up to 'max_batch_size'
      ///@@     inference requests. Requests are chosen in an oldest-first
      ///@@     manner across all candidate sequences. A given sequence is
      ///@@     not guaranteed to be assigned to the same batch slot for
      ///@@     all inference requests of that sequence.
      ///@@
      /// </summary>
      public sealed partial class StrategyOldest : pb::IMessage<StrategyOldest> {
        private static readonly pb::MessageParser<StrategyOldest> _parser = new pb::MessageParser<StrategyOldest>(() => new StrategyOldest());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<StrategyOldest> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public StrategyOldest() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public StrategyOldest(StrategyOldest other) : this() {
          maxCandidateSequences_ = other.maxCandidateSequences_;
          preferredBatchSize_ = other.preferredBatchSize_.Clone();
          maxQueueDelayMicroseconds_ = other.maxQueueDelayMicroseconds_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public StrategyOldest Clone() {
          return new StrategyOldest(this);
        }

        /// <summary>Field number for the "max_candidate_sequences" field.</summary>
        public const int MaxCandidateSequencesFieldNumber = 1;
        private int maxCandidateSequences_;
        /// <summary>
        ///@@    .. cpp:var:: int32 max_candidate_sequences
        ///@@
        ///@@       Maximum number of candidate sequences that the batcher
        ///@@       maintains. Excess seqences are kept in an ordered backlog
        ///@@       and become candidates when existing candidate sequences
        ///@@       complete.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int MaxCandidateSequences {
          get { return maxCandidateSequences_; }
          set {
            maxCandidateSequences_ = value;
          }
        }

        /// <summary>Field number for the "preferred_batch_size" field.</summary>
        public const int PreferredBatchSizeFieldNumber = 2;
        private static readonly pb::FieldCodec<int> _repeated_preferredBatchSize_codec
            = pb::FieldCodec.ForInt32(18);
        private readonly pbc::RepeatedField<int> preferredBatchSize_ = new pbc::RepeatedField<int>();
        /// <summary>
        ///@@    .. cpp:var:: int32 preferred_batch_size (repeated)
        ///@@
        ///@@       Preferred batch sizes for dynamic batching of candidate
        ///@@       sequences. If a batch of one of these sizes can be formed
        ///@@       it will be executed immediately.  If not specified a
        ///@@       preferred batch size will be chosen automatically
        ///@@       based on model and GPU characteristics.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<int> PreferredBatchSize {
          get { return preferredBatchSize_; }
        }

        /// <summary>Field number for the "max_queue_delay_microseconds" field.</summary>
        public const int MaxQueueDelayMicrosecondsFieldNumber = 3;
        private ulong maxQueueDelayMicroseconds_;
        /// <summary>
        ///@@    .. cpp:var:: uint64 max_queue_delay_microseconds
        ///@@
        ///@@       The maximum time, in microseconds, a candidate request
        ///@@       will be delayed in the dynamic batch scheduling queue to
        ///@@       wait for additional requests for batching. Default is 0.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ulong MaxQueueDelayMicroseconds {
          get { return maxQueueDelayMicroseconds_; }
          set {
            maxQueueDelayMicroseconds_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as StrategyOldest);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(StrategyOldest other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (MaxCandidateSequences != other.MaxCandidateSequences) return false;
          if(!preferredBatchSize_.Equals(other.preferredBatchSize_)) return false;
          if (MaxQueueDelayMicroseconds != other.MaxQueueDelayMicroseconds) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (MaxCandidateSequences != 0) hash ^= MaxCandidateSequences.GetHashCode();
          hash ^= preferredBatchSize_.GetHashCode();
          if (MaxQueueDelayMicroseconds != 0UL) hash ^= MaxQueueDelayMicroseconds.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (MaxCandidateSequences != 0) {
            output.WriteRawTag(8);
            output.WriteInt32(MaxCandidateSequences);
          }
          preferredBatchSize_.WriteTo(output, _repeated_preferredBatchSize_codec);
          if (MaxQueueDelayMicroseconds != 0UL) {
            output.WriteRawTag(24);
            output.WriteUInt64(MaxQueueDelayMicroseconds);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (MaxCandidateSequences != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxCandidateSequences);
          }
          size += preferredBatchSize_.CalculateSize(_repeated_preferredBatchSize_codec);
          if (MaxQueueDelayMicroseconds != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MaxQueueDelayMicroseconds);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(StrategyOldest other) {
          if (other == null) {
            return;
          }
          if (other.MaxCandidateSequences != 0) {
            MaxCandidateSequences = other.MaxCandidateSequences;
          }
          preferredBatchSize_.Add(other.preferredBatchSize_);
          if (other.MaxQueueDelayMicroseconds != 0UL) {
            MaxQueueDelayMicroseconds = other.MaxQueueDelayMicroseconds;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                MaxCandidateSequences = input.ReadInt32();
                break;
              }
              case 18:
              case 16: {
                preferredBatchSize_.AddEntriesFrom(input, _repeated_preferredBatchSize_codec);
                break;
              }
              case 24: {
                MaxQueueDelayMicroseconds = input.ReadUInt64();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelEnsembling
  ///@@
  ///@@   Model ensembling configuration. These settings specify the models that
  ///@@   compose the ensemble and how data flows between the models.
  ///@@
  /// </summary>
  public sealed partial class ModelEnsembling : pb::IMessage<ModelEnsembling> {
    private static readonly pb::MessageParser<ModelEnsembling> _parser = new pb::MessageParser<ModelEnsembling>(() => new ModelEnsembling());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ModelEnsembling> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Triton.MemoryAnalyzer.Client.ModelConfigReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelEnsembling() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelEnsembling(ModelEnsembling other) : this() {
      step_ = other.step_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelEnsembling Clone() {
      return new ModelEnsembling(this);
    }

    /// <summary>Field number for the "step" field.</summary>
    public const int StepFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Triton.MemoryAnalyzer.Client.ModelEnsembling.Types.Step> _repeated_step_codec
        = pb::FieldCodec.ForMessage(10, global::Triton.MemoryAnalyzer.Client.ModelEnsembling.Types.Step.Parser);
    private readonly pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelEnsembling.Types.Step> step_ = new pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelEnsembling.Types.Step>();
    /// <summary>
    ///@@  .. cpp:var:: Step step (repeated)
    ///@@
    ///@@     The models and the input / output mappings used within the ensemble.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelEnsembling.Types.Step> Step {
      get { return step_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ModelEnsembling);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ModelEnsembling other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!step_.Equals(other.step_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= step_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      step_.WriteTo(output, _repeated_step_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += step_.CalculateSize(_repeated_step_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ModelEnsembling other) {
      if (other == null) {
        return;
      }
      step_.Add(other.step_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            step_.AddEntriesFrom(input, _repeated_step_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ModelEnsembling message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///@@  .. cpp:var:: message Step
      ///@@
      ///@@     Each step specifies a model included in the ensemble,
      ///@@     maps ensemble tensor names to the model input tensors,
      ///@@     and maps model output tensors to ensemble tensor names
      ///@@
      /// </summary>
      public sealed partial class Step : pb::IMessage<Step> {
        private static readonly pb::MessageParser<Step> _parser = new pb::MessageParser<Step>(() => new Step());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Step> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Triton.MemoryAnalyzer.Client.ModelEnsembling.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Step() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Step(Step other) : this() {
          modelName_ = other.modelName_;
          modelVersion_ = other.modelVersion_;
          inputMap_ = other.inputMap_.Clone();
          outputMap_ = other.outputMap_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Step Clone() {
          return new Step(this);
        }

        /// <summary>Field number for the "model_name" field.</summary>
        public const int ModelNameFieldNumber = 1;
        private string modelName_ = "";
        /// <summary>
        ///@@  .. cpp:var:: string model_name
        ///@@
        ///@@     The name of the model to execute for this step of the ensemble.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string ModelName {
          get { return modelName_; }
          set {
            modelName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "model_version" field.</summary>
        public const int ModelVersionFieldNumber = 2;
        private long modelVersion_;
        /// <summary>
        ///@@  .. cpp:var:: int64 model_version
        ///@@
        ///@@     The version of the model to use for inference. If -1
        ///@@     the latest/most-recent version of the model is used.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long ModelVersion {
          get { return modelVersion_; }
          set {
            modelVersion_ = value;
          }
        }

        /// <summary>Field number for the "input_map" field.</summary>
        public const int InputMapFieldNumber = 3;
        private static readonly pbc::MapField<string, string>.Codec _map_inputMap_codec
            = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 26);
        private readonly pbc::MapField<string, string> inputMap_ = new pbc::MapField<string, string>();
        /// <summary>
        ///@@  .. cpp:var:: map&lt;string,string> input_map
        ///@@
        ///@@     Map from name of an input tensor on this step's model to ensemble
        ///@@     tensor name. The ensemble tensor must have the same data type and
        ///@@     shape as the model input. Each model input must be assigned to
        ///@@     one ensemble tensor, but the same ensemble tensor can be assigned
        ///@@     to multiple model inputs.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, string> InputMap {
          get { return inputMap_; }
        }

        /// <summary>Field number for the "output_map" field.</summary>
        public const int OutputMapFieldNumber = 4;
        private static readonly pbc::MapField<string, string>.Codec _map_outputMap_codec
            = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 34);
        private readonly pbc::MapField<string, string> outputMap_ = new pbc::MapField<string, string>();
        /// <summary>
        ///@@  .. cpp:var:: map&lt;string,string> output_map
        ///@@
        ///@@     Map from name of an output tensor on this step's model to ensemble
        ///@@     tensor name. The data type and shape of the ensemble tensor will
        ///@@     be inferred from the model output. It is optional to assign all
        ///@@     model outputs to ensemble tensors. One ensemble tensor name
        ///@@     can appear in an output map only once.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, string> OutputMap {
          get { return outputMap_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Step);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Step other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ModelName != other.ModelName) return false;
          if (ModelVersion != other.ModelVersion) return false;
          if (!InputMap.Equals(other.InputMap)) return false;
          if (!OutputMap.Equals(other.OutputMap)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (ModelName.Length != 0) hash ^= ModelName.GetHashCode();
          if (ModelVersion != 0L) hash ^= ModelVersion.GetHashCode();
          hash ^= InputMap.GetHashCode();
          hash ^= OutputMap.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (ModelName.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(ModelName);
          }
          if (ModelVersion != 0L) {
            output.WriteRawTag(16);
            output.WriteInt64(ModelVersion);
          }
          inputMap_.WriteTo(output, _map_inputMap_codec);
          outputMap_.WriteTo(output, _map_outputMap_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (ModelName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(ModelName);
          }
          if (ModelVersion != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(ModelVersion);
          }
          size += inputMap_.CalculateSize(_map_inputMap_codec);
          size += outputMap_.CalculateSize(_map_outputMap_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Step other) {
          if (other == null) {
            return;
          }
          if (other.ModelName.Length != 0) {
            ModelName = other.ModelName;
          }
          if (other.ModelVersion != 0L) {
            ModelVersion = other.ModelVersion;
          }
          inputMap_.Add(other.inputMap_);
          outputMap_.Add(other.outputMap_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                ModelName = input.ReadString();
                break;
              }
              case 16: {
                ModelVersion = input.ReadInt64();
                break;
              }
              case 26: {
                inputMap_.AddEntriesFrom(input, _map_inputMap_codec);
                break;
              }
              case 34: {
                outputMap_.AddEntriesFrom(input, _map_outputMap_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelParameter
  ///@@
  ///@@   A model parameter.
  ///@@
  /// </summary>
  public sealed partial class ModelParameter : pb::IMessage<ModelParameter> {
    private static readonly pb::MessageParser<ModelParameter> _parser = new pb::MessageParser<ModelParameter>(() => new ModelParameter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ModelParameter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Triton.MemoryAnalyzer.Client.ModelConfigReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelParameter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelParameter(ModelParameter other) : this() {
      stringValue_ = other.stringValue_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelParameter Clone() {
      return new ModelParameter(this);
    }

    /// <summary>Field number for the "string_value" field.</summary>
    public const int StringValueFieldNumber = 1;
    private string stringValue_ = "";
    /// <summary>
    ///@@  .. cpp:var:: string string_value
    ///@@
    ///@@     The string value of the parameter.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StringValue {
      get { return stringValue_; }
      set {
        stringValue_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ModelParameter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ModelParameter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (StringValue != other.StringValue) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (StringValue.Length != 0) hash ^= StringValue.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (StringValue.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(StringValue);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (StringValue.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StringValue);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ModelParameter other) {
      if (other == null) {
        return;
      }
      if (other.StringValue.Length != 0) {
        StringValue = other.StringValue;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            StringValue = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelWarmup
  ///@@
  ///@@   Settings used to construct the request sample for model warmup.
  ///@@
  /// </summary>
  public sealed partial class ModelWarmup : pb::IMessage<ModelWarmup> {
    private static readonly pb::MessageParser<ModelWarmup> _parser = new pb::MessageParser<ModelWarmup>(() => new ModelWarmup());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ModelWarmup> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Triton.MemoryAnalyzer.Client.ModelConfigReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelWarmup() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelWarmup(ModelWarmup other) : this() {
      name_ = other.name_;
      batchSize_ = other.batchSize_;
      inputs_ = other.inputs_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelWarmup Clone() {
      return new ModelWarmup(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    ///@@  .. cpp:var:: string name
    ///@@
    ///@@     The name of the request sample.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "batch_size" field.</summary>
    public const int BatchSizeFieldNumber = 2;
    private uint batchSize_;
    /// <summary>
    ///@@  .. cpp:var:: uint32 batch_size
    ///@@
    ///@@     The batch size of the inference request. This must be >= 1. For
    ///@@     models that don't support batching, batch_size must be 1. If
    ///@@     batch_size > 1, the 'inputs' specified below will be duplicated to
    ///@@     match the batch size requested.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BatchSize {
      get { return batchSize_; }
      set {
        batchSize_ = value;
      }
    }

    /// <summary>Field number for the "inputs" field.</summary>
    public const int InputsFieldNumber = 3;
    private static readonly pbc::MapField<string, global::Triton.MemoryAnalyzer.Client.ModelWarmup.Types.Input>.Codec _map_inputs_codec
        = new pbc::MapField<string, global::Triton.MemoryAnalyzer.Client.ModelWarmup.Types.Input>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Triton.MemoryAnalyzer.Client.ModelWarmup.Types.Input.Parser), 26);
    private readonly pbc::MapField<string, global::Triton.MemoryAnalyzer.Client.ModelWarmup.Types.Input> inputs_ = new pbc::MapField<string, global::Triton.MemoryAnalyzer.Client.ModelWarmup.Types.Input>();
    /// <summary>
    ///@@  .. cpp:var:: map&lt;string, Input> inputs
    ///@@
    ///@@     The warmup meta data associated with every model input, including
    ///@@     control tensors.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Triton.MemoryAnalyzer.Client.ModelWarmup.Types.Input> Inputs {
      get { return inputs_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ModelWarmup);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ModelWarmup other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (BatchSize != other.BatchSize) return false;
      if (!Inputs.Equals(other.Inputs)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (BatchSize != 0) hash ^= BatchSize.GetHashCode();
      hash ^= Inputs.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (BatchSize != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(BatchSize);
      }
      inputs_.WriteTo(output, _map_inputs_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (BatchSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BatchSize);
      }
      size += inputs_.CalculateSize(_map_inputs_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ModelWarmup other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.BatchSize != 0) {
        BatchSize = other.BatchSize;
      }
      inputs_.Add(other.inputs_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            BatchSize = input.ReadUInt32();
            break;
          }
          case 26: {
            inputs_.AddEntriesFrom(input, _map_inputs_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ModelWarmup message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///@@
      ///@@  .. cpp:var:: message Input
      ///@@
      ///@@     Meta data associated with an input.
      ///@@
      /// </summary>
      public sealed partial class Input : pb::IMessage<Input> {
        private static readonly pb::MessageParser<Input> _parser = new pb::MessageParser<Input>(() => new Input());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Input> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Triton.MemoryAnalyzer.Client.ModelWarmup.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Input() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Input(Input other) : this() {
          dataType_ = other.dataType_;
          dims_ = other.dims_.Clone();
          switch (other.InputDataTypeCase) {
            case InputDataTypeOneofCase.ZeroData:
              ZeroData = other.ZeroData;
              break;
            case InputDataTypeOneofCase.RandomData:
              RandomData = other.RandomData;
              break;
            case InputDataTypeOneofCase.InputDataFile:
              InputDataFile = other.InputDataFile;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Input Clone() {
          return new Input(this);
        }

        /// <summary>Field number for the "data_type" field.</summary>
        public const int DataTypeFieldNumber = 1;
        private global::Triton.MemoryAnalyzer.Client.DataType dataType_ = 0;
        /// <summary>
        ///@@    .. cpp:var:: DataType data_type
        ///@@
        ///@@       The data-type of the input.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Triton.MemoryAnalyzer.Client.DataType DataType {
          get { return dataType_; }
          set {
            dataType_ = value;
          }
        }

        /// <summary>Field number for the "dims" field.</summary>
        public const int DimsFieldNumber = 2;
        private static readonly pb::FieldCodec<long> _repeated_dims_codec
            = pb::FieldCodec.ForInt64(18);
        private readonly pbc::RepeatedField<long> dims_ = new pbc::RepeatedField<long>();
        /// <summary>
        ///@@    .. cpp:var:: int64 dims (repeated)
        ///@@
        ///@@       The shape of the input tensor, not including the batch dimension.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<long> Dims {
          get { return dims_; }
        }

        /// <summary>Field number for the "zero_data" field.</summary>
        public const int ZeroDataFieldNumber = 3;
        /// <summary>
        ///@@
        ///@@    .. cpp:var:: bool zero_data
        ///@@
        ///@@       The identifier for using zeros as input data. Note that the
        ///@@       value of 'zero_data' will not be checked, instead, zero data
        ///@@       will be used as long as the field is set.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool ZeroData {
          get { return inputDataTypeCase_ == InputDataTypeOneofCase.ZeroData ? (bool) inputDataType_ : false; }
          set {
            inputDataType_ = value;
            inputDataTypeCase_ = InputDataTypeOneofCase.ZeroData;
          }
        }

        /// <summary>Field number for the "random_data" field.</summary>
        public const int RandomDataFieldNumber = 4;
        /// <summary>
        ///@@
        ///@@    .. cpp:var:: bool random_data
        ///@@
        ///@@       The identifier for using random data as input data. Note that
        ///@@       the value of 'random_data' will not be checked, instead,
        ///@@       random data will be used as long as the field is set.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool RandomData {
          get { return inputDataTypeCase_ == InputDataTypeOneofCase.RandomData ? (bool) inputDataType_ : false; }
          set {
            inputDataType_ = value;
            inputDataTypeCase_ = InputDataTypeOneofCase.RandomData;
          }
        }

        /// <summary>Field number for the "input_data_file" field.</summary>
        public const int InputDataFileFieldNumber = 5;
        /// <summary>
        ///@@    .. cpp:var:: string input_data_file
        ///@@
        ///@@       The file whose content will be used as raw input data in
        ///@@       row-major order. The file must be provided in a sub-directory
        ///@@       'warmup' under the model directory.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string InputDataFile {
          get { return inputDataTypeCase_ == InputDataTypeOneofCase.InputDataFile ? (string) inputDataType_ : ""; }
          set {
            inputDataType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            inputDataTypeCase_ = InputDataTypeOneofCase.InputDataFile;
          }
        }

        private object inputDataType_;
        /// <summary>Enum of possible cases for the "input_data_type" oneof.</summary>
        public enum InputDataTypeOneofCase {
          None = 0,
          ZeroData = 3,
          RandomData = 4,
          InputDataFile = 5,
        }
        private InputDataTypeOneofCase inputDataTypeCase_ = InputDataTypeOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public InputDataTypeOneofCase InputDataTypeCase {
          get { return inputDataTypeCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearInputDataType() {
          inputDataTypeCase_ = InputDataTypeOneofCase.None;
          inputDataType_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Input);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Input other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (DataType != other.DataType) return false;
          if(!dims_.Equals(other.dims_)) return false;
          if (ZeroData != other.ZeroData) return false;
          if (RandomData != other.RandomData) return false;
          if (InputDataFile != other.InputDataFile) return false;
          if (InputDataTypeCase != other.InputDataTypeCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (DataType != 0) hash ^= DataType.GetHashCode();
          hash ^= dims_.GetHashCode();
          if (inputDataTypeCase_ == InputDataTypeOneofCase.ZeroData) hash ^= ZeroData.GetHashCode();
          if (inputDataTypeCase_ == InputDataTypeOneofCase.RandomData) hash ^= RandomData.GetHashCode();
          if (inputDataTypeCase_ == InputDataTypeOneofCase.InputDataFile) hash ^= InputDataFile.GetHashCode();
          hash ^= (int) inputDataTypeCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (DataType != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) DataType);
          }
          dims_.WriteTo(output, _repeated_dims_codec);
          if (inputDataTypeCase_ == InputDataTypeOneofCase.ZeroData) {
            output.WriteRawTag(24);
            output.WriteBool(ZeroData);
          }
          if (inputDataTypeCase_ == InputDataTypeOneofCase.RandomData) {
            output.WriteRawTag(32);
            output.WriteBool(RandomData);
          }
          if (inputDataTypeCase_ == InputDataTypeOneofCase.InputDataFile) {
            output.WriteRawTag(42);
            output.WriteString(InputDataFile);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (DataType != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DataType);
          }
          size += dims_.CalculateSize(_repeated_dims_codec);
          if (inputDataTypeCase_ == InputDataTypeOneofCase.ZeroData) {
            size += 1 + 1;
          }
          if (inputDataTypeCase_ == InputDataTypeOneofCase.RandomData) {
            size += 1 + 1;
          }
          if (inputDataTypeCase_ == InputDataTypeOneofCase.InputDataFile) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(InputDataFile);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Input other) {
          if (other == null) {
            return;
          }
          if (other.DataType != 0) {
            DataType = other.DataType;
          }
          dims_.Add(other.dims_);
          switch (other.InputDataTypeCase) {
            case InputDataTypeOneofCase.ZeroData:
              ZeroData = other.ZeroData;
              break;
            case InputDataTypeOneofCase.RandomData:
              RandomData = other.RandomData;
              break;
            case InputDataTypeOneofCase.InputDataFile:
              InputDataFile = other.InputDataFile;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                DataType = (global::Triton.MemoryAnalyzer.Client.DataType) input.ReadEnum();
                break;
              }
              case 18:
              case 16: {
                dims_.AddEntriesFrom(input, _repeated_dims_codec);
                break;
              }
              case 24: {
                ZeroData = input.ReadBool();
                break;
              }
              case 32: {
                RandomData = input.ReadBool();
                break;
              }
              case 42: {
                InputDataFile = input.ReadString();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelConfig
  ///@@
  ///@@   A model configuration.
  ///@@
  /// </summary>
  public sealed partial class ModelConfig : pb::IMessage<ModelConfig> {
    private static readonly pb::MessageParser<ModelConfig> _parser = new pb::MessageParser<ModelConfig>(() => new ModelConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ModelConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Triton.MemoryAnalyzer.Client.ModelConfigReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelConfig(ModelConfig other) : this() {
      name_ = other.name_;
      platform_ = other.platform_;
      versionPolicy_ = other.versionPolicy_ != null ? other.versionPolicy_.Clone() : null;
      maxBatchSize_ = other.maxBatchSize_;
      input_ = other.input_.Clone();
      output_ = other.output_.Clone();
      optimization_ = other.optimization_ != null ? other.optimization_.Clone() : null;
      instanceGroup_ = other.instanceGroup_.Clone();
      defaultModelFilename_ = other.defaultModelFilename_;
      ccModelFilenames_ = other.ccModelFilenames_.Clone();
      metricTags_ = other.metricTags_.Clone();
      parameters_ = other.parameters_.Clone();
      modelWarmup_ = other.modelWarmup_.Clone();
      switch (other.SchedulingChoiceCase) {
        case SchedulingChoiceOneofCase.DynamicBatching:
          DynamicBatching = other.DynamicBatching.Clone();
          break;
        case SchedulingChoiceOneofCase.SequenceBatching:
          SequenceBatching = other.SequenceBatching.Clone();
          break;
        case SchedulingChoiceOneofCase.EnsembleScheduling:
          EnsembleScheduling = other.EnsembleScheduling.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelConfig Clone() {
      return new ModelConfig(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    ///@@  .. cpp:var:: string name
    ///@@
    ///@@     The name of the model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "platform" field.</summary>
    public const int PlatformFieldNumber = 2;
    private string platform_ = "";
    /// <summary>
    ///@@  .. cpp:var:: string platform
    ///@@
    ///@@     The framework for the model. Possible values are
    ///@@     "tensorrt_plan", "tensorflow_graphdef",
    ///@@     "tensorflow_savedmodel", "caffe2_netdef",
    ///@@     "onnxruntime_onnx", "pytorch_libtorch" and "custom".
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Platform {
      get { return platform_; }
      set {
        platform_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "version_policy" field.</summary>
    public const int VersionPolicyFieldNumber = 3;
    private global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy versionPolicy_;
    /// <summary>
    ///@@  .. cpp:var:: ModelVersionPolicy version_policy
    ///@@
    ///@@     Policy indicating which version(s) of the model will be served.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy VersionPolicy {
      get { return versionPolicy_; }
      set {
        versionPolicy_ = value;
      }
    }

    /// <summary>Field number for the "max_batch_size" field.</summary>
    public const int MaxBatchSizeFieldNumber = 4;
    private int maxBatchSize_;
    /// <summary>
    ///@@  .. cpp:var:: int32 max_batch_size
    ///@@
    ///@@     Maximum batch size allowed for inference. This can only decrease
    ///@@     what is allowed by the model itself. A max_batch_size value of 0
    ///@@     indicates that batching is not allowed for the model and the
    ///@@     dimension/shape of the input and output tensors must exactly
    ///@@     match what is specified in the input and output configuration. A
    ///@@     max_batch_size value > 0 indicates that batching is allowed and
    ///@@     so the model expects the input tensors to have an additional
    ///@@     initial dimension for the batching that is not specified in the
    ///@@     input (for example, if the model supports batched inputs of
    ///@@     2-dimensional tensors then the model configuration will specify
    ///@@     the input shape as [ X, Y ] but the model will expect the actual
    ///@@     input tensors to have shape [ N, X, Y ]). For max_batch_size > 0
    ///@@     returned outputs will also have an additional initial dimension
    ///@@     for the batch.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxBatchSize {
      get { return maxBatchSize_; }
      set {
        maxBatchSize_ = value;
      }
    }

    /// <summary>Field number for the "input" field.</summary>
    public const int InputFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Triton.MemoryAnalyzer.Client.ModelInput> _repeated_input_codec
        = pb::FieldCodec.ForMessage(42, global::Triton.MemoryAnalyzer.Client.ModelInput.Parser);
    private readonly pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelInput> input_ = new pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelInput>();
    /// <summary>
    ///@@  .. cpp:var:: ModelInput input (repeated)
    ///@@
    ///@@     The inputs request by the model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelInput> Input {
      get { return input_; }
    }

    /// <summary>Field number for the "output" field.</summary>
    public const int OutputFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Triton.MemoryAnalyzer.Client.ModelOutput> _repeated_output_codec
        = pb::FieldCodec.ForMessage(50, global::Triton.MemoryAnalyzer.Client.ModelOutput.Parser);
    private readonly pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelOutput> output_ = new pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelOutput>();
    /// <summary>
    ///@@  .. cpp:var:: ModelOutput output (repeated)
    ///@@
    ///@@     The outputs produced by the model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelOutput> Output {
      get { return output_; }
    }

    /// <summary>Field number for the "optimization" field.</summary>
    public const int OptimizationFieldNumber = 12;
    private global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy optimization_;
    /// <summary>
    ///@@  .. cpp:var:: ModelOptimizationPolicy optimization
    ///@@
    ///@@     Optimization configuration for the model. If not specified
    ///@@     then default optimization policy is used.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy Optimization {
      get { return optimization_; }
      set {
        optimization_ = value;
      }
    }

    /// <summary>Field number for the "dynamic_batching" field.</summary>
    public const int DynamicBatchingFieldNumber = 11;
    /// <summary>
    ///@@    .. cpp:var:: ModelDynamicBatching dynamic_batching
    ///@@
    ///@@       If specified, enables the dynamic-batching scheduling
    ///@@       policy. With dynamic-batching the scheduler may group
    ///@@       together independent requests into a single batch to
    ///@@       improve inference throughput.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Triton.MemoryAnalyzer.Client.ModelDynamicBatching DynamicBatching {
      get { return schedulingChoiceCase_ == SchedulingChoiceOneofCase.DynamicBatching ? (global::Triton.MemoryAnalyzer.Client.ModelDynamicBatching) schedulingChoice_ : null; }
      set {
        schedulingChoice_ = value;
        schedulingChoiceCase_ = value == null ? SchedulingChoiceOneofCase.None : SchedulingChoiceOneofCase.DynamicBatching;
      }
    }

    /// <summary>Field number for the "sequence_batching" field.</summary>
    public const int SequenceBatchingFieldNumber = 13;
    /// <summary>
    ///@@    .. cpp:var:: ModelSequenceBatching sequence_batching
    ///@@
    ///@@       If specified, enables the sequence-batching scheduling
    ///@@       policy. With sequence-batching, inference requests
    ///@@       with the same correlation ID are routed to the same
    ///@@       model instance. Multiple sequences of inference requests
    ///@@       may be batched together into a single batch to
    ///@@       improve inference throughput.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching SequenceBatching {
      get { return schedulingChoiceCase_ == SchedulingChoiceOneofCase.SequenceBatching ? (global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching) schedulingChoice_ : null; }
      set {
        schedulingChoice_ = value;
        schedulingChoiceCase_ = value == null ? SchedulingChoiceOneofCase.None : SchedulingChoiceOneofCase.SequenceBatching;
      }
    }

    /// <summary>Field number for the "ensemble_scheduling" field.</summary>
    public const int EnsembleSchedulingFieldNumber = 15;
    /// <summary>
    ///@@    .. cpp:var:: ModelEnsembling ensemble_scheduling
    ///@@
    ///@@       If specified, enables the model-ensembling scheduling
    ///@@       policy. With model-ensembling, inference requests
    ///@@       will be processed according to the specification, such as an
    ///@@       execution sequence of models. The input specified in this model
    ///@@       config will be the input for the ensemble, and the output
    ///@@       specified will be the output of the ensemble.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Triton.MemoryAnalyzer.Client.ModelEnsembling EnsembleScheduling {
      get { return schedulingChoiceCase_ == SchedulingChoiceOneofCase.EnsembleScheduling ? (global::Triton.MemoryAnalyzer.Client.ModelEnsembling) schedulingChoice_ : null; }
      set {
        schedulingChoice_ = value;
        schedulingChoiceCase_ = value == null ? SchedulingChoiceOneofCase.None : SchedulingChoiceOneofCase.EnsembleScheduling;
      }
    }

    /// <summary>Field number for the "instance_group" field.</summary>
    public const int InstanceGroupFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Triton.MemoryAnalyzer.Client.ModelInstanceGroup> _repeated_instanceGroup_codec
        = pb::FieldCodec.ForMessage(58, global::Triton.MemoryAnalyzer.Client.ModelInstanceGroup.Parser);
    private readonly pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelInstanceGroup> instanceGroup_ = new pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelInstanceGroup>();
    /// <summary>
    ///@@  .. cpp:var:: ModelInstanceGroup instance_group (repeated)
    ///@@
    ///@@     Instances of this model. If not specified, one instance
    ///@@     of the model will be instantiated on each available GPU.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelInstanceGroup> InstanceGroup {
      get { return instanceGroup_; }
    }

    /// <summary>Field number for the "default_model_filename" field.</summary>
    public const int DefaultModelFilenameFieldNumber = 8;
    private string defaultModelFilename_ = "";
    /// <summary>
    ///@@  .. cpp:var:: string default_model_filename
    ///@@
    ///@@     Optional filename of the model file to use if a
    ///@@     compute-capability specific model is not specified in
    ///@@     :cpp:var:`cc_model_filenames`. If not specified the default name
    ///@@     is 'model.graphdef', 'model.savedmodel', 'model.plan' or
    ///@@     'model.netdef' depending on the model type.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DefaultModelFilename {
      get { return defaultModelFilename_; }
      set {
        defaultModelFilename_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "cc_model_filenames" field.</summary>
    public const int CcModelFilenamesFieldNumber = 9;
    private static readonly pbc::MapField<string, string>.Codec _map_ccModelFilenames_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 74);
    private readonly pbc::MapField<string, string> ccModelFilenames_ = new pbc::MapField<string, string>();
    /// <summary>
    ///@@  .. cpp:var:: map&lt;string,string> cc_model_filenames
    ///@@
    ///@@     Optional map from CUDA compute capability to the filename of
    ///@@     the model that supports that compute capability. The filename
    ///@@     refers to a file within the model version directory.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> CcModelFilenames {
      get { return ccModelFilenames_; }
    }

    /// <summary>Field number for the "metric_tags" field.</summary>
    public const int MetricTagsFieldNumber = 10;
    private static readonly pbc::MapField<string, string>.Codec _map_metricTags_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 82);
    private readonly pbc::MapField<string, string> metricTags_ = new pbc::MapField<string, string>();
    /// <summary>
    ///@@  .. cpp:var:: map&lt;string,string> metric_tags
    ///@@
    ///@@     Optional metric tags. User-specific key-value pairs for metrics
    ///@@     reported for this model. These tags are applied to the metrics
    ///@@     reported on the HTTP metrics port.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> MetricTags {
      get { return metricTags_; }
    }

    /// <summary>Field number for the "parameters" field.</summary>
    public const int ParametersFieldNumber = 14;
    private static readonly pbc::MapField<string, global::Triton.MemoryAnalyzer.Client.ModelParameter>.Codec _map_parameters_codec
        = new pbc::MapField<string, global::Triton.MemoryAnalyzer.Client.ModelParameter>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Triton.MemoryAnalyzer.Client.ModelParameter.Parser), 114);
    private readonly pbc::MapField<string, global::Triton.MemoryAnalyzer.Client.ModelParameter> parameters_ = new pbc::MapField<string, global::Triton.MemoryAnalyzer.Client.ModelParameter>();
    /// <summary>
    ///@@  .. cpp:var:: map&lt;string,ModelParameter> parameters
    ///@@
    ///@@     Optional model parameters. User-specified parameter values that
    ///@@     are made available to custom backends.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Triton.MemoryAnalyzer.Client.ModelParameter> Parameters {
      get { return parameters_; }
    }

    /// <summary>Field number for the "model_warmup" field.</summary>
    public const int ModelWarmupFieldNumber = 16;
    private static readonly pb::FieldCodec<global::Triton.MemoryAnalyzer.Client.ModelWarmup> _repeated_modelWarmup_codec
        = pb::FieldCodec.ForMessage(130, global::Triton.MemoryAnalyzer.Client.ModelWarmup.Parser);
    private readonly pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelWarmup> modelWarmup_ = new pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelWarmup>();
    /// <summary>
    ///@@  .. cpp:var:: ModelWarmup model_warmup (repeated)
    ///@@
    ///@@     Warmup setting of this model. If specified, all instances
    ///@@     will be run with the request samples in sequence before
    ///@@     serving the model.
    ///@@     This field can only be specified if the model is not an ensemble
    ///@@     model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Triton.MemoryAnalyzer.Client.ModelWarmup> ModelWarmup {
      get { return modelWarmup_; }
    }

    private object schedulingChoice_;
    /// <summary>Enum of possible cases for the "scheduling_choice" oneof.</summary>
    public enum SchedulingChoiceOneofCase {
      None = 0,
      DynamicBatching = 11,
      SequenceBatching = 13,
      EnsembleScheduling = 15,
    }
    private SchedulingChoiceOneofCase schedulingChoiceCase_ = SchedulingChoiceOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SchedulingChoiceOneofCase SchedulingChoiceCase {
      get { return schedulingChoiceCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSchedulingChoice() {
      schedulingChoiceCase_ = SchedulingChoiceOneofCase.None;
      schedulingChoice_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ModelConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ModelConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Platform != other.Platform) return false;
      if (!object.Equals(VersionPolicy, other.VersionPolicy)) return false;
      if (MaxBatchSize != other.MaxBatchSize) return false;
      if(!input_.Equals(other.input_)) return false;
      if(!output_.Equals(other.output_)) return false;
      if (!object.Equals(Optimization, other.Optimization)) return false;
      if (!object.Equals(DynamicBatching, other.DynamicBatching)) return false;
      if (!object.Equals(SequenceBatching, other.SequenceBatching)) return false;
      if (!object.Equals(EnsembleScheduling, other.EnsembleScheduling)) return false;
      if(!instanceGroup_.Equals(other.instanceGroup_)) return false;
      if (DefaultModelFilename != other.DefaultModelFilename) return false;
      if (!CcModelFilenames.Equals(other.CcModelFilenames)) return false;
      if (!MetricTags.Equals(other.MetricTags)) return false;
      if (!Parameters.Equals(other.Parameters)) return false;
      if(!modelWarmup_.Equals(other.modelWarmup_)) return false;
      if (SchedulingChoiceCase != other.SchedulingChoiceCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Platform.Length != 0) hash ^= Platform.GetHashCode();
      if (versionPolicy_ != null) hash ^= VersionPolicy.GetHashCode();
      if (MaxBatchSize != 0) hash ^= MaxBatchSize.GetHashCode();
      hash ^= input_.GetHashCode();
      hash ^= output_.GetHashCode();
      if (optimization_ != null) hash ^= Optimization.GetHashCode();
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.DynamicBatching) hash ^= DynamicBatching.GetHashCode();
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.SequenceBatching) hash ^= SequenceBatching.GetHashCode();
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.EnsembleScheduling) hash ^= EnsembleScheduling.GetHashCode();
      hash ^= instanceGroup_.GetHashCode();
      if (DefaultModelFilename.Length != 0) hash ^= DefaultModelFilename.GetHashCode();
      hash ^= CcModelFilenames.GetHashCode();
      hash ^= MetricTags.GetHashCode();
      hash ^= Parameters.GetHashCode();
      hash ^= modelWarmup_.GetHashCode();
      hash ^= (int) schedulingChoiceCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Platform.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Platform);
      }
      if (versionPolicy_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(VersionPolicy);
      }
      if (MaxBatchSize != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(MaxBatchSize);
      }
      input_.WriteTo(output, _repeated_input_codec);
      output_.WriteTo(output, _repeated_output_codec);
      instanceGroup_.WriteTo(output, _repeated_instanceGroup_codec);
      if (DefaultModelFilename.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(DefaultModelFilename);
      }
      ccModelFilenames_.WriteTo(output, _map_ccModelFilenames_codec);
      metricTags_.WriteTo(output, _map_metricTags_codec);
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.DynamicBatching) {
        output.WriteRawTag(90);
        output.WriteMessage(DynamicBatching);
      }
      if (optimization_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Optimization);
      }
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.SequenceBatching) {
        output.WriteRawTag(106);
        output.WriteMessage(SequenceBatching);
      }
      parameters_.WriteTo(output, _map_parameters_codec);
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.EnsembleScheduling) {
        output.WriteRawTag(122);
        output.WriteMessage(EnsembleScheduling);
      }
      modelWarmup_.WriteTo(output, _repeated_modelWarmup_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Platform.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Platform);
      }
      if (versionPolicy_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VersionPolicy);
      }
      if (MaxBatchSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxBatchSize);
      }
      size += input_.CalculateSize(_repeated_input_codec);
      size += output_.CalculateSize(_repeated_output_codec);
      if (optimization_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Optimization);
      }
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.DynamicBatching) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DynamicBatching);
      }
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.SequenceBatching) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SequenceBatching);
      }
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.EnsembleScheduling) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EnsembleScheduling);
      }
      size += instanceGroup_.CalculateSize(_repeated_instanceGroup_codec);
      if (DefaultModelFilename.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DefaultModelFilename);
      }
      size += ccModelFilenames_.CalculateSize(_map_ccModelFilenames_codec);
      size += metricTags_.CalculateSize(_map_metricTags_codec);
      size += parameters_.CalculateSize(_map_parameters_codec);
      size += modelWarmup_.CalculateSize(_repeated_modelWarmup_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ModelConfig other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Platform.Length != 0) {
        Platform = other.Platform;
      }
      if (other.versionPolicy_ != null) {
        if (versionPolicy_ == null) {
          VersionPolicy = new global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy();
        }
        VersionPolicy.MergeFrom(other.VersionPolicy);
      }
      if (other.MaxBatchSize != 0) {
        MaxBatchSize = other.MaxBatchSize;
      }
      input_.Add(other.input_);
      output_.Add(other.output_);
      if (other.optimization_ != null) {
        if (optimization_ == null) {
          Optimization = new global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy();
        }
        Optimization.MergeFrom(other.Optimization);
      }
      instanceGroup_.Add(other.instanceGroup_);
      if (other.DefaultModelFilename.Length != 0) {
        DefaultModelFilename = other.DefaultModelFilename;
      }
      ccModelFilenames_.Add(other.ccModelFilenames_);
      metricTags_.Add(other.metricTags_);
      parameters_.Add(other.parameters_);
      modelWarmup_.Add(other.modelWarmup_);
      switch (other.SchedulingChoiceCase) {
        case SchedulingChoiceOneofCase.DynamicBatching:
          if (DynamicBatching == null) {
            DynamicBatching = new global::Triton.MemoryAnalyzer.Client.ModelDynamicBatching();
          }
          DynamicBatching.MergeFrom(other.DynamicBatching);
          break;
        case SchedulingChoiceOneofCase.SequenceBatching:
          if (SequenceBatching == null) {
            SequenceBatching = new global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching();
          }
          SequenceBatching.MergeFrom(other.SequenceBatching);
          break;
        case SchedulingChoiceOneofCase.EnsembleScheduling:
          if (EnsembleScheduling == null) {
            EnsembleScheduling = new global::Triton.MemoryAnalyzer.Client.ModelEnsembling();
          }
          EnsembleScheduling.MergeFrom(other.EnsembleScheduling);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Platform = input.ReadString();
            break;
          }
          case 26: {
            if (versionPolicy_ == null) {
              VersionPolicy = new global::Triton.MemoryAnalyzer.Client.ModelVersionPolicy();
            }
            input.ReadMessage(VersionPolicy);
            break;
          }
          case 32: {
            MaxBatchSize = input.ReadInt32();
            break;
          }
          case 42: {
            input_.AddEntriesFrom(input, _repeated_input_codec);
            break;
          }
          case 50: {
            output_.AddEntriesFrom(input, _repeated_output_codec);
            break;
          }
          case 58: {
            instanceGroup_.AddEntriesFrom(input, _repeated_instanceGroup_codec);
            break;
          }
          case 66: {
            DefaultModelFilename = input.ReadString();
            break;
          }
          case 74: {
            ccModelFilenames_.AddEntriesFrom(input, _map_ccModelFilenames_codec);
            break;
          }
          case 82: {
            metricTags_.AddEntriesFrom(input, _map_metricTags_codec);
            break;
          }
          case 90: {
            global::Triton.MemoryAnalyzer.Client.ModelDynamicBatching subBuilder = new global::Triton.MemoryAnalyzer.Client.ModelDynamicBatching();
            if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.DynamicBatching) {
              subBuilder.MergeFrom(DynamicBatching);
            }
            input.ReadMessage(subBuilder);
            DynamicBatching = subBuilder;
            break;
          }
          case 98: {
            if (optimization_ == null) {
              Optimization = new global::Triton.MemoryAnalyzer.Client.ModelOptimizationPolicy();
            }
            input.ReadMessage(Optimization);
            break;
          }
          case 106: {
            global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching subBuilder = new global::Triton.MemoryAnalyzer.Client.ModelSequenceBatching();
            if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.SequenceBatching) {
              subBuilder.MergeFrom(SequenceBatching);
            }
            input.ReadMessage(subBuilder);
            SequenceBatching = subBuilder;
            break;
          }
          case 114: {
            parameters_.AddEntriesFrom(input, _map_parameters_codec);
            break;
          }
          case 122: {
            global::Triton.MemoryAnalyzer.Client.ModelEnsembling subBuilder = new global::Triton.MemoryAnalyzer.Client.ModelEnsembling();
            if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.EnsembleScheduling) {
              subBuilder.MergeFrom(EnsembleScheduling);
            }
            input.ReadMessage(subBuilder);
            EnsembleScheduling = subBuilder;
            break;
          }
          case 130: {
            modelWarmup_.AddEntriesFrom(input, _repeated_modelWarmup_codec);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
